{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fmodern\fcharset0 CourierNewPSMT;\f2\fnil\fcharset0 Calibri;
\f3\fswiss\fcharset0 Helvetica;\f4\fnil\fcharset0 Cambria;\f5\fmodern\fcharset0 Courier;
\f6\fnil\fcharset0 Menlo-Regular;\f7\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
{\info
{\author Eric Lyon}
{\*\company Sonic Arts Research Centre}}\paperw11900\paperh16840\vieww18060\viewh17240\viewkind1\viewscale125
\deftab720
\pard\pardeftab720\ri0\qc

\f0\fs40 \cf0 Complete Code Figures from\
\'93Designing Audio Objects\'94 by Eric Lyon\
\pard\pardeftab720\ri0\qc

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs40 \
\
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\b0\fs20 \cf0  1 outlets = 2;\
 2 \
 3 function buildsine()\
 4 \{\
 5 	var length = 1024;\
 6 	var i;\
 7 	var sineval;\
 8 	for(i = 0; i < length; i++)\{\
 9 		sineval = Math.sin(2 * Math.PI * i / length);\
10 		outlet(1,sineval); // set the value\
11 		outlet(0,i); // send index trigger buffer write\
12 	\}\
13 \}\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 2.6
\f4\b0  
\f0 JavaScript code to generate a sine wave
\f4 \
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\b0\fs20 \cf0 1 for(i = 0; i < sample_count, i++) \{\
2   output[i] = input1[i] * input2[i];\
3 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.1
\f4\b0  
\f0 A C 
\f1\fs20 for
\f0\fs24  loop to multiply the contents of two arrays\

\f4 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(1)\{\
2   readsamp(&input1, &input2); // hypothetical read function\
3   output = input1 * input2; // do the multiplication\
4   writesamp(&output); // hypothetical write function\
5 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.2
\f4\b0  An infinite 
\f1\fs20 while
\f4\fs24  loop for multiplying two input sample streams\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for(i = 0; i < n; i++)\{\
2   out[i] = in1[i] * in2[i];\
3 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.3
\f4\b0  Processing Max signal vectors with a signal vector size of 
\f1\fs20 n 
\f4\fs24 samples\
\
\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(n--)\{\
2   *out++ = *in1++ * *in2++;\
3 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.4
\f4\b0  Processing Max signal vectors using pointer arithmetic\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #include "ext.h" \
#include "z_dsp.h" \
#include "ext_obex.h"\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.5
\f0\b0  Required header files for Max/MSP audio DSP objects\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _multy \{\
  t_pxobject obj;\
\} t_multy;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\tx4973\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.6
\f4\b0  The Max/MSP object structure
\f0 \
\pard\pardeftab720\ri0\ql\qnatural

\f4 \cf0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 struct multy \{ t_pxobject obj; \};\
typedef struct _multy t_multy;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.7
\f0\b0  The object structure from figure 3.6 with structure and type defined separately\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct \{\
  t_pxobject obj;\
\} t_multy;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.8
\f0\b0  A more compact combined object structure and type definition\
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\b0\fs20 \cf0 static t_class *multy_class;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.9
\f0\b0  The 
\i multy~
\i0  class pointer\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *multy_new(void);\
void multy_dsp(t_multy *x, t_signal **sp, short *count);
\f4 \

\f1 t_int *multy_perform(t_int *w);\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.10
\f0\b0  Function prototypes\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *multy_new(void); \
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.11
\f0\b0  The first line of the 
\f1\fs20 multy_new()
\f0\fs24  function.\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 int main(void)\
 2 \{\
 3 	multy_class = class_new("multy~", (method)multy_new, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (method)dsp_free, sizeof(t_multy), 0,0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  4 	class_addmethod(multy_class,(method)multy_dsp, "dsp",A_CANT,0);\
 5 	class_dspinit(multy_class);\
 6 	class_register(CLASS_BOX, multy_class);\
 7 	post("multy~ from \\"Designing Audio Objects\\" by Eric Lyon");\
 8 	return 0;\
 9 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.12
\f0\b0  The initialization routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void *multy_new(void)\
2 \{\
3 	t_multy *x = (t_multy *)object_alloc(multy_class);\
4 	dsp_setup((t_pxobject *)x, 2);\
5 	outlet_new((t_object *)x, "signal");\
6 	return x;\
7 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.13
\f0\b0  The new instance routine. \
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\b0\fs20 \cf0 1 void multy_dsp(t_multy *x, t_signal **sp, short *count)\
2 \{\
3 	dsp_add(multy_perform, 5, x, sp[0]->s_vec, sp[1]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 4 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.14
\f0\b0  The 
\i multy~
\i0  dsp method.\
\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void multy_dsp(t_multy *x, t_signal **sp, short *count)\
2 \{\
3   dsp_add(multy_perform, 5, x, sp[0]->s_vec-1, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 sp[1]->s_vec-1, sp[2]->s_vec-1, sp[0]->s_n+1);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 4 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.15
\f0\b0  A pre-decrement/increment form of the dsp method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(--n)\{\
2   *++out = *++in1 * *++in2;\
3 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.16
\f0\b0  The perform loop in pre-decrement/increment processing\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 t_int *multy_perform(t_int *w)\
 2 \{\
 3 	t_multy *x = (t_multy *) (w[1]);\
 4 	t_float *in1 = (t_float *) (w[2]);\
 5 	t_float *in2 = (t_float *) (w[3]);\
 6 	t_float *out = (t_float *) (w[4]);\
 7 	t_int n = w[5];\
 8 	\
 9 	while(n--)\{\
10 		*out++ = *in1++ * *in2++;\
11 	\}\
12 	return w + 6;\
13 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.17
\f0\b0  The 
\i multy~
\i0  perform routine\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \page  1 void multy_assist(t_multy *x, void *b, long msg, long arg, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 char *dst)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3   if (msg==ASSIST_INLET) \{\
 4     switch (arg) \{\
 5     case 0:\
 6       sprintf(dst,"(signal) Input 1");\
 7       break;\
 8     case 1:\
 9       sprintf(dst,"(signal) Input 2");\
10       break;\
11     \}\
12   \} \
13   else if (msg==ASSIST_OUTLET) \{\
14     sprintf(dst,"(signal) Output");\
15   \}\
16 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.19
\f0\b0  The assist method.\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void multy_assist(t_multy *x, void *b, long msg, long arg, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 char *dst);\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.20
\f0\b0  The assist function prototype\
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\b0\fs20 \cf0 class_addmethod(multy_class,(method)multy_assist, "assist", \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 A_CANT, 0);\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.21
\f0\b0  Binding the assist method to the 
\i multy~
\i0  class\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #include "m_pd.h"\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.24
\f0\b0  The required Pd header\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 static t_class *multy_class;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.25
\f0\b0  The Pd 
\i multy~
\i0  class pointer\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _multy\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 \{	\
	t_object obj;\
	t_float x_f;\
\} t_multy;\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.26
\f0\b0  The Pd object structure\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *multy_new(void);\
void multy_dsp(t_multy *x, t_signal **sp, short *count);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 t_int *multy_perform(t_int *w);\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.27
\f0\b0  The Pd function prototypes\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void multy_tilde_setup (void)\
2 \{\
\pard\pardeftab720\li720\fi-720\ri0\ql\qnatural
\cf0 3 	multy_class = class_new(gensym("multy~"),       \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (t_newmethod)multy_new, 0, sizeof(t_multy), 0, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 4 	CLASS_MAINSIGNALIN(multy_class, t_multy, x_f);\
5 	class_addmethod(multy_class, (t_method)multy_dsp, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("dsp"),0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 6 	post("multy~ from \\"Designing Audio Objects\\" by Eric Lyon");\
7 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.28
\f0\b0  The Pd class definition function\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
1 void *multy_new( void )\
2 \{\
3     t_multy *x = (t_multy *) pd_new(multy_class);\
4 	inlet_new(&x->obj, &x->obj.ob_pd, gensym("signal"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("signal"));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 5     outlet_new(&x->obj, gensym("signal"));\
6     return x;\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\b0\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 3.29
\f0\b0  The Pd new instance routine for 
\i multy~\
\pard\pardeftab720\ri0\ql\qnatural

\f2\i0\b\fs26 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\b0\fs24 \cf0 \
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float my_array[64];\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.2
\f0\b0  Static memory allocation\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 float max_ms = 250;
\f4 \

\f1 2 int srate = 44100;\
3 int delay_length;\
4 delay_length = max_ms * 0.001 * (float) srate;\
5 delay_length += 1;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.3
\f0\b0  Calculating the size of the memory in samples\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float *delay_line;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.4
\f0\b0  The delay line, defined as a pointer to floats\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 delay_line = (float *) sysmem_newptr(100000 * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.5
\f0\b0  Allocating dynamic memory for the delay line\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float delay_line[100000]; // cannot use in Max object structure\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.6
\f0\b0  Static memory allocation for the delay line\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 float *delay_line;\
2 delay_bytes = delay_length * sizeof(float);\
3 delay_line = (float *) sysmem_newptr(delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.7
\f0\b0  Dynamic memory allocation based on the desired size of the delay line\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 int write_index = 0; // initialized outside perform method\
 2 // *input is the MSP buffer containing the signal to be delayed\
 3 while(n--)\{\
 4   // write sample into next available location and increment index\
 5   delay_line[write_index++] = *input;\
 6   // keep within range of the array length\
 7   if( write_index >= delay_length)\{\
 8     write_index -= delay_length;\
 9   \}\
10 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.8
\f0\b0  Writing to a circular buffer\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(n--)\{\
2   *output++ = delay_line[read_index - 4410];\
3   delay_line[read_index++] = *input++;\
4   if( read_index >= delay_length)\{\
5     read_index -= delay_length;\
6   \}\
7 \}\
\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 ____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.9
\f0\b0  First attempt at reading from a circular buffer\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 read_index = write_index - 4410;\
2 while(read_index < 0)\
3   read_index += delay_length;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.10
\f0\b0  Avoiding illegal indexing\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(n--)\{\
2   *output++ = *input++ * gain;\
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.11
\f0\b0  Typical DSP code where buffer sharing works correctly\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 1 out_sample = delay_line[read_index++];\
2 delay_line[write_index++] = *input++;\
3 *output++ = out_sample;\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.12
\f0\b0  Storing the input sample before writing over it\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs20 \cf0 1 dsp_setup((t_pxobject *)x, 3); //initialize object with 3 inlets
\f1 \

\f4 2 x->obj.z_misc |= Z_NO_INPLACE; //force independent signal vectors
\f1 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.13
\f0\b0  Setting the Max/MSP flag to prohibit buffer sharing\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 int idelay;\
2 idelay = round(ms_delay * sr * 0.001);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.14
\f0\b0  Truncating the delay time \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void vdelay_dsp(t_vdelay *x, t_signal **sp, short *count)\
2 \{\
3   dsp_add(vdelay_perform, 6, x, sp[0]->s_vec, sp[1]->s_vec, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.15
\f0\b0  The dsp method for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 typedef struct _vdelay \{\
  t_pxobject obj;\
  float sr; // sampling rate\
  float maximum_delay_time; // maximum delay time\
  long delay_length; // length of the delay line in samples\
  long delay_bytes; // length of delay line in bytes\
  float *delay_line; // the delay line itself\
  float delay_time; // current delay time\
  float feedback; // feedback multiplier\
  long write_index; // write point in delay line\
  long read_index; // read point in delay line\
  short delaytime_connected; // inlet connection status\
  short feedback_connected; // inlet connection status\
\} t_vdelay;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.16
\f0\b0  The object structure for 
\i vdelay~\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \
\
 \
\page  1 void *vdelay_new(t_symbol *s, short argc, t_atom *argv)\
 2 \{\
 3 	int i; \
 4 	float delmax = 100.0, deltime = 100.0, feedback = 0.1;\
 5 	t_vdelay *x = object_alloc(vdelay_class);\
 6 	dsp_setup((t_pxobject *)x, 3);\
 7 	outlet_new((t_object *)x, "signal");\
 8 	x->obj.z_misc |= Z_NO_INPLACE;\
 9 	x->sr = sys_getsr(); \
10 	\
11 	atom_arg_getfloat(&delmax, 0, argc, argv);\
12 	atom_arg_getfloat(&deltime, 1, argc, argv);\
13 	atom_arg_getfloat(&feedback, 2, argc, argv);\
14 \
15 	if(delmax <= 0)\{\
16 		delmax = 250.0; \
17 	\}\
18 	x->maximum_delay_time = delmax * 0.001;\
19 	\
20 	x->delay_time = deltime; \
21 	if(x->delay_time > delmax || x->delay_time <= 0.0)\{\
22 		error("vdelay~: illegal delay time: %f", x->delay_time);\
23 		x->delay_time = 1.0;\
24 	\}\
25 	x->delay_length = x->sr * x->maximum_delay_time + 1;\
26 	x->delay_bytes = x->delay_length * sizeof(float);\
27 	x->delay_line = (float *) sysmem_newptr(x->delay_bytes);\
28 	if(x->delay_line == NULL)\{\
29 		error("vdelay~: cannot allocate %d bytes of memory", \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 30 		return NULL;\
31 	\}\
32 	for(i = 0; i < x->delay_length; i++)\{\
33 		x->delay_line[i] = 0.0;\
34 	\}\
35 	x->feedback = feedback;\
36 	x->write_index = 0;\
37 	return x;\
38 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.17
\f0\b0  The new instance routine for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 dsp_setup(&x->obj, 3);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.18
\f0\b0  Passing a pointer to the proxy object component without casting\
\pard\pardeftab720\ri0\ql\qnatural

\b \cf0 \
\
\
\
\
\
\
\
\
  
\f1\b0\fs20 1 t_int *vdelay_perform(t_int *w)\
 2 \{\
 3 	t_vdelay *x = (t_vdelay *) (w[1]);\
 4 	t_float *input = (t_float *) (w[2]);\
 5 	t_float *delaytime = (t_float *) (w[3]);\
 6 	t_float *feedback = (t_float *) (w[4]);\
 7 	t_float *output = (t_float *) (w[5]);\
 8 	t_int n = w[6];\
 9 	float sr = x->sr;\
10 	float *delay_line = x->delay_line;\
11 	long read_index = x->read_index;\
12 	long write_index = x->write_index;\
13 	long delay_length = x->delay_length;\
14 	long idelay;\
15 	float srms = sr / 1000.0;\
16 	float out_sample;\
17 	\
18 	while(n--)\{\
19 		idelay = round(*delaytime++ * srms);\
20 		if(idelay < 0)\{\
21 			idelay = 0;\
22 		\}\
23 		else if(idelay > delay_length)\{\
24 			idelay = delay_length - 1;\
25 		\}\
26 		read_index = write_index - idelay;\
27 		while(read_index < 0)\{\
28 			read_index += delay_length;\
29 		\}\
30 		out_sample = delay_line[read_index];\
31 		delay_line[write_index++] = \
			*input++ + out_sample * *feedback++;\
32 		*output++ = out_sample;\
33 		if(write_index >= delay_length)\{\
34 			write_index -= delay_length;\
35 		\}\
36 	\}\
37 	x->write_index = write_index;\
38 	return w + 7;\
39 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.19
\f0\b0  The perform routine for 
\i vdelay~
\i0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  1 void vdelay_assist(t_vdelay *x, void *b, long msg, long arg, \
	char *dst)\
 2 \{\
 3 	if (msg == ASSIST_INLET) \{\
 4 		switch (arg) \{\
 5 			case 0: sprintf(dst,"(signal) Input"); break;\
 6 			case 1: sprintf(dst,"(signal) Delay Time"); break;\
 7 			case 2: sprintf(dst,"(signal) Feedback"); break;\
 8 		\}\
 9 	\} \
10 	else if (msg == ASSIST_OUTLET) \{\
11 		sprintf(dst,"(signal) Output");\
12 	\}\
13 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.20
\f0\b0  The assist method for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 void vdelay_free(t_vdelay *x)\
2 \{\
3 	dsp_free((t_pxobject *) x);\
4 	sysmem_freeptr(x->delay_line);\
5 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.21
\f0\b0  The free function for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 int main(void)\
 2 \{	\
 3 	vdelay_class = class_new("vdelay~",\
 		(method)vdelay_new,(method)vdelay_free,\
 		sizeof(t_vdelay),0,A_GIMME,0);\
 4 	class_addmethod(vdelay_class, (method)vdelay_dsp, "dsp", \
 		A_CANT, 0);\
 5 	class_addmethod(vdelay_class, (method)vdelay_assist, "assist", \
 		A_CANT, 0);\
 6 	class_dspinit(vdelay_class);\
 7 	class_register(CLASS_BOX, vdelay_class);\
 8 	post("vdelay~ from \\\'94Designing Audio Objects\\\'94 by Eric Lyon");\
 9 	return 0;\
10 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.22
\f0\b0  The initialization routine for 
\i vdelay~\
\
\
\
\
\
\
\
\
  
\f1\i0\fs20 1 void vdelay_dsp(t_vdelay *x, t_signal **sp, short *count)\
 2 \{\
 3 	int i;\
 4 	if(x->sr != sp[0]->s_sr)\{\
 5 		x->sr = sp[0]->s_sr; \
 6 		x->delay_length = x->sr * x->maximum_delay_time + 1;\
 7 		x->delay_bytes = x->delay_length * sizeof(float);\
 8 		x->delay_line = \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (float *) sysmem_resizeptr((void *)x->delay_line,\
x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  9 		if(x->delay_line == NULL)\{\
10 			error("vdelay~: cannot realloc %d bytes of memory",\
 				x->delay_bytes);\
11 			return;\
12 		\}\
13 		for(i = 0; i < x->delay_length; i++)\{ \
14 			x->delay_line[i] = 0.0;\
15 		\}\
16 		x->write_index = 0; \
17 	\}\
18 	dsp_add(vdelay_perform, 6, x, sp[0]->s_vec, sp[1]->s_vec,\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 19 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.24
\f0\b0  The revised dsp method for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 void vdelay_float(t_vdelay *x, double f)\
 2 \{\
 3 	int inlet = ((t_pxobject*)x)->z_in;\
 4 	switch(inlet)\{\
 5 		case 1: // 2nd inlet\
 6 			if(f < 0.0 ||\
 7 			   f > x->maximum_delay_time * 1000.0)\{\
 8 				error("vdelay~: illegal delay: %f", f);\
 9 			\} else \{\
10 				x->delay_time = f;\
11 			\}\
12 			break;\
13 		case 2: // 3rd inlet\
14 			x->feedback = f;\
15 			break;\
16 	\}\
17 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.25
\f0\b0  The float method for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 class_addmethod(vdelay_class,(method)vdelay_float,"float",A_FLOAT,0);
\f0\fs24 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.26
\f0\b0  Binding the float method\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->delaytime_connected = count[1];\
2 x->feedback_connected = count[2];\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.27
\f0\b0  Storing the connection states of the rightmost two inlets\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \page  1 t_int *vdelay_perform(t_int *w)\
 2 \{\
 3 	t_vdelay *x = (t_vdelay *) (w[1]);\
 4 	t_float *input = (t_float *) (w[2]);\
 5 	t_float *delaytime = (t_float *) (w[3]);\
 6 	t_float *feedback = (t_float *) (w[4]);\
 7 	t_float *output = (t_float *) (w[5]);\
 8 	t_int n = w[6];\
 9 	float sr = x->sr;\
10 	float *delay_line = x->delay_line;\
11 	long read_index = x->read_index;\
12 	long write_index = x->write_index;\
13 	long delay_length = x->delay_length;\
14 	short delaytime_connected = x->delaytime_connected;\
15 	short feedback_connected = x->feedback_connected;\
16 	float delaytime_float = x->delay_time;\
17 	float feedback_float = x->feedback;	\
18 	long idelay;\
19 	float srms = sr / 1000.0;\
20 	float out_sample;\
21 	\
22 	while(n--)\{\
23 		if(delaytime_connected)\{\
24 			idelay = round(*delaytime++ * srms);\
25 		\}\
26 		else \{ \
27 			idelay = round(delaytime_float * srms); \
28 		\}\
29 		if(idelay < 0)\{\
30 			idelay = 0;\
31 		\}\
32 		else if( idelay > delay_length)\{\
33 			idelay = delay_length - 1;\
34 		\}\
35 		read_index = write_index - idelay;\
36 		while(read_index < 0)\{\
37 			read_index += delay_length;\
38 		\}\
39 		out_sample = delay_line[read_index];\
40 		if(feedback_connected) \{\
41 			delay_line[write_index++] = *input++ \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 + out_sample * *feedback++;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 42 		\}\
43 		else \{ \
44 			delay_line[write_index++] = *input++ \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 + out_sample * feedback_float;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 45 		\}		\
46 		*output++ = out_sample;\
47 		if(write_index >= delay_length)\{\
48 			write_index -= delay_length;\
49 		\}\
50 	\}\
51 	x->write_index = write_index;\
52 	return w + 7;\
53 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \

\f3\b Figure 4.28
\f0\b0  The 
\i vdelay~
\i0  perform routine modified to accept float or signal input\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page sprintf(dest, "(signal/float) Delay Time");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.29
\f0\b0  Assist string indicating that either float or signal input is accepted\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 1 fraction = delaytime \'96 trunc(delaytime);\
2 m1 = 1. - fraction;\
3 m2 = fraction;\
4 interp_sample = m1 * samp1 + m2 * samp2; \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.30
\f0\b0  Code to implement linear interpolation\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 interp_sample = samp1 + fraction * (samp2 \'96 samp1); \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.31
\f0\b0  A more efficient calculation of linear interpolation\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \page  
\fs18 1 t_int *vdelay_perform(t_int *w)
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  2 \{
\fs20 \

\fs18  3 	t_vdelay *x = (t_vdelay *) (w[1]);
\fs20 \

\fs18  4 	t_float *input = (t_float *) (w[2]);
\fs20 \

\fs18  5 	t_float *delaytime = (t_float *) (w[3]);
\fs20 \

\fs18  6 	t_float *feedback = (t_float *) (w[4]);
\fs20 \

\fs18  7 	t_float *output = (t_float *) (w[5]);
\fs20 \

\fs18  8 	t_int n = w[6];	
\fs20 \

\fs18  9 	float sr = x->sr;
\fs20 \

\fs18 10 	float *delay_line = x->delay_line;
\fs20 \

\fs18 11 	long read_index = x->read_index;
\fs20 \

\fs18 12 	long write_index = x->write_index;
\fs20 \

\fs18 13 	long delay_length = x->delay_length;
\fs20 \

\fs18 14 	short delaytime_connected = x->delaytime_connected;
\fs20 \

\fs18 15 	short feedback_connected = x->feedback_connected;
\fs20 \

\fs18 16 	float delaytime_float = x->delay_time;
\fs20 \

\fs18 17 	float feedback_float = x->feedback;	
\fs20 \

\fs18 18 	float fraction;
\fs20 \

\fs18 19 	float fdelay;
\fs20 \

\fs18 20 	float samp1, samp2;
\fs20 \

\fs18 21 	long idelay;
\fs20 \

\fs18 22 	float srms = sr / 1000.0;
\fs20 \

\fs18 23 	float out_sample;
\fs20 \

\fs18 24 	
\fs20 \

\fs18 25 	while(n--)\{
\fs20 \

\fs18 26 		if(delaytime_connected)\{
\fs20 \

\fs18 27 			fdelay = *delaytime++ * srms;
\fs20 \

\fs18 28 		\}
\fs20 \

\fs18 29 		else \{ 
\fs20 \

\fs18 30 			fdelay = delaytime_float * srms; 
\fs20 \

\fs18 31 		\}
\fs20 \

\fs18 32 		while(fdelay < 0)\{
\fs20 \

\fs18 33 			fdelay += delay_length;
\fs20 \

\fs18 34 		\}
\fs20 \

\fs18 35 		idelay = trunc(fdelay);
\fs20 \

\fs18 36 		fraction = fdelay - idelay;
\fs20 \

\fs18 37 		read_index = write_index - idelay;
\fs20 \

\fs18 38 		while(read_index < 0)\{
\fs20 \

\fs18 39 			read_index += delay_length;
\fs20 \

\fs18 40 		\}
\fs20 \

\fs18 41 		samp1 = delay_line[read_index];
\fs20 \

\fs18 42 		samp2 = delay_line[(read_index + 1) % delay_length];
\fs20 \

\fs18 43 		out_sample = samp1 + fraction * (samp2-samp1);
\fs20 \

\fs18 44 		if(feedback_connected) \{
\fs20 \

\fs18 45 			delay_line[write_index++] = *input++ 
\fs20 \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural

\fs18 \cf0 + out_sample * *feedback++;
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 46 		\}
\fs20 \

\fs18 47 		else \{ 
\fs20 \

\fs18 48 			delay_line[write_index++] = *input++ 
\fs20 \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural

\fs18 \cf0 + out_sample * feedback_float;
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 49 		\}		
\fs20 \

\fs18 50 		*output++ = out_sample;
\fs20 \

\fs18 51 		if(write_index >= delay_length)\{
\fs20 \

\fs18 52 			write_index -= delay_length;
\fs20 \

\fs18 53 		\}
\fs20 \

\fs18 54 	\}
\fs20 \

\fs18 55 	x->write_index = write_index;
\fs20 \

\fs18 56 	return w + 7;
\fs20 \

\fs18 57 \}
\fs20 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.32
\f0\b0  The 
\i vdelay~
\i0  perform routine with delay-line interpolation \
\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page #include "m_pd.h"\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 #include "math.h"\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.33
\f0\b0  Required header files for the Pd version of 
\i vdelay~
\i0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 t_object obj; // t_object rather than t_pxobject\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 t_float x_f; // convert float to signal\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.34
\f0\b0  Slight changes to the Pd object structure\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 1 void vdelay_tilde_setup (void)\
2 \{	\
3 	vdelay_class = 											class_new(gensym("vdelay~"),(t_newmethod)vdelay_new,\
		(t_method)vdelay_free,sizeof(t_vdelay),0,A_GIMME,0);\
4 	CLASS_MAINSIGNALIN(vdelay_class, t_vdelay, x_f);\
5 	class_addmethod(vdelay_class, (t_method)vdelay_dsp, 					gensym("dsp"), A_CANT, 0);\
6 	post("vdelay~: from Designing Audio Objects (Pd version)");\
7 \}\
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.35
\f0\b0  The class definition routine for Pd version of 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\page  1 void *vdelay_new(t_symbol *s, short argc, t_atom *argv)\
 2 \{\
 3 	int i; \
 4 	float delmax = 100.0, deltime = 100.0, feedback = 0.1;\
 5 	t_vdelay *x = (t_vdelay *) pd_new(vdelay_class);\
 6 	inlet_new(&x->obj, &x->obj.ob_pd, gensym("signal"), 				gensym("signal"));\
 7 	inlet_new(&x->obj, &x->obj.ob_pd, gensym("signal"), 				gensym("signal"));\
 8     outlet_new(&x->obj, gensym("signal"));\
 9 	x->sr = sys_getsr(); \
10 	if(argc >= 3)\{ feedback = atom_getfloatarg(2, argc, argv); \}\
11 	if(argc >= 2)\{ deltime = atom_getfloatarg(1, argc, argv); \}\
12 	if(argc >= 1)\{ delmax = atom_getfloatarg(0, argc, argv); \}\
13 	if(delmax <= 0)\{\
14 		delmax = 250.0; \
15 	\}\
16 	x->maximum_delay_time = delmax * 0.001; \
17 	x->delay_time = deltime; \
18 	if(x->delay_time > delmax || x->delay_time <= 0.0)\{\
19 		error("bad delay time: %f, reset to 1 ms", \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->delay_time);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 20 		x->delay_time = 1.0;\
21 	\}\
22 	x->delay_length = x->sr * x->maximum_delay_time + 1;\
23 	x->delay_bytes = x->delay_length * sizeof(float);\
24 	x->delay_line = (float *) getbytes(x->delay_bytes); \
25 	if(x->delay_line == NULL)\{\
26 		error("vdelay~: cannot allocate %d bytes of memory", \
			x->delay_bytes);\
27 		return NULL;\
28 	\}\
29 	for(i = 0; i < x->delay_length; i++)\{\
30 		x->delay_line[i] = 0.0;\
31 	\}\
32 	x->feedback = feedback;\
33 	x->write_index = 0;\
34 	return x;\
35 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.36
\f0\b0  The Pd version of the new instance routine for 
\i vdelay~\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 void vdelay_dsp(t_vdelay *x, t_signal **sp)\
 2 \{\
 3 	int i;\
 4 	int oldbytes = x->delay_bytes;\
 5 	x->delaytime_connected = 1;\
 6 	x->feedback_connected = 1;\
 7 	if(x->sr != sp[0]->s_sr)\{\
 8 		x->sr = sp[0]->s_sr; \
 9 		x->delay_length = x->sr * x->maximum_delay_time + 1;\
10 		x->delay_bytes = x->delay_length * sizeof(float);\
11 		x->delay_line = (float *) resizebytes(\
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (void *)x->delay_line,oldbytes,x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 12 		if(x->delay_line == NULL)\{\
13 			error("vdelay~: cannot realloc %d bytes of memory", 					x->delay_bytes);\
14 			return;\
15 		\}\
16 		for(i = 0; i < x->delay_length; i++)\{ \
17 			x->delay_line[i] = 0.0;\
18 		\}\
19 		x->write_index = 0; \
20 	\}\
21 	dsp_add(vdelay_perform, 6, x, sp[0]->s_vec, sp[1]->s_vec,\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 22 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.37
\f0\b0  The Pd version of the dsp method for 
\i vdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 void vdelay_free(t_vdelay *x)\
2 \{\
3 	freebytes(x->delay_line, x->delay_bytes);\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\li43\fi-43\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 4.38
\f0\b0  The Pd version of the free function for 
\i vdelay~
\i0 \
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\b0\fs20 \cf0  1 #define TWOPI 6.28318530717959\
 2 int length = 1024;\
 3 int i;\
 4 float wavetable[LENGTH];\
 5 float phase;\
 6 main()\{\
 7 for(i = 0; i < length; i++)\{\
 8   phase = TWOPI * (float) i / (float) length;\
 9   wavetable[i] = sin(phase);\
10  \}\
11 \}\
\
_____________________________________________________________________
\f2\b\fs26 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\fs24 \cf0 Figure 5.1
\f0\b0  Generating and storing a digital sine wave\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 for( i = 0; i < length; i++ )\{\
2   wavetable[i] = sin(TWOPI * (float) i / (float) length);\
3 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.2
\f0\b0  A more compact loop for generating a sine wave\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 twopi = 8 * atan(1);\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.4
\f0\b0  Programmatically generating 2\uc0\u960 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs20 \cf0 1 for(i = 0; i < length; i++)\{
\f1 \

\f4 2   wavetable[i] = amplitudes[0]; 
\f1 \

\f4 3 \}
\f1 \
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.5
\f0\b0  Setting the DC component in code\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 phase = TWOPI * (float) i / (float) length;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.8
\f0\b0  Computing the running phase of a digital sine wave\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 phase = TWOPI * (float) j * (float) i / (float) length;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.9
\f0\b0  Computing the running phase for multiple harmonics\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for(j = 1; j < harmonic_count; j++)\{\
2   for(i = 0; i < length; i++)\{\
3     phase = TWOPI * (float) j * (float) i / (float) length ;\
4     wavetable[i] += amplitudes[j] * sin(phase);\
5   \}\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.10
\f0\b0  Adding harmonics to the wavetable\
\
\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for(j = 1; j < harmonic_count; j++)\{\
2   j2piolen = (float) j * TWOPI / (float) length;\
3   for(i = 0; i < length; i++)\{\
4     wavetable[i] += amplitudes[j] * sin(j2piolen * (float)i);\
5   \}\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.11
\f0\b0  A more efficient coding for adding harmonics to the wavetable\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 if(amplitudes[j] != 0.0) \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.12
\f0\b0  A test for making sure the amplitude of a harmonic is not zero\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 if(amplitudes[j]) \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.13
\f0\b0  A more compact test condition\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 for(i = 0; i < length; i++)\{\
 2   wavetable[i] = amplitudes[0];\
 3 \}\
 4 for(j = 1; j < harmonic_count; j++)\{\
 5   if(amplitudes[j])\{\
 6     j2piolen = (float) j * TWOPI / (float) length;\
 7     for(i = 0; i < length; i++)\{\
 8       wavetable[i] += amplitudes[j] * sin(j2piolen * (float)i);\
 9     \}\
10   \}\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.14
\f0\b0  Summing all components of the waveform\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\page  1 float max = 0.0;\
 2 for(i = 0; i < table_length; i++)\{\
 3   if(max < fabs(wavetable[i])\{\
 4     max = fabs(wavetable[i]);\
 5   \}\
 6 \}\
 7 \
 8 if(max == 0.0) \{ //avoid divide by zero error\
 9   /* could send an error message here */\
10   return;\
11 \}\
12 rescale = 1.0 / max;\
13 for(i = 0; i < length; i++)\{\
14   wavetable [i] *= rescale;\
15 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.15
\f0\b0  A normalizing algorithm\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for(i = 0; i < table_length/2 ; i++)\{\
2   if(max < fabs(wavetable[i]))\{\
3     max = fabs(wavetable[i]);\
4   \}\
5 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.17
\f0\b0  More efficient symmetry, assuming sine phase for all harmonics\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 if(max == 0.0)\{\
2   error("all zero wavetable!");\
3 	return;\
4 \}\
5 rescale = 1.0 / max ;\
6 for( j = 0; j < table_length; j++ )\{	\
7   wavetable[j] *= rescale ;\
8 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.18
\f0\b0  Rescaling\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 sampling_increment =  frequency * table_length / sampling_rate\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.19
\f0\b0  Calculating the sampling increment\
\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 \page \pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #define OSCIL_DEFAULT_TABLESIZE 8192\
#define OSCIL_DEFAULT_HARMS 10\
#define OSCIL_MAX_HARMS 1024\
#define OSCIL_DEFAULT_FREQUENCY 440.0\
#define OSCIL_DEFAULT_WAVEFORM "sine"\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 #define OSCIL_MAX_TABLESIZE 1048576\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.20
\f0\b0  Defining constants for 
\i oscil~\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 typedef struct _oscil\
\{\
	t_pxobject obj; // required for all Max/MSP objects\
	long table_length; // length of wavetable\
	float *wavetable; // wavetable\
	float *amplitudes; // list of amplitudes for each harmonic\
	t_symbol *waveform; // the waveform used currently\
	long harmonic_count; // number of harmonics\
	float phase; // phase\
	float si; // sampling increment\
	float si_factor; // factor for generating sampling increment\
	long bl_harms; // number of harmonics for band limited waveforms\
	float piotwo; // pi over two\
	float twopi; // two times pi\
	float sr; // sampling rate\
	long wavetable_bytes;// number of bytes stored in wavetable\
	long amplitude_bytes;// number of bytes stored in amplitude table\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \} t_oscil;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.21
\f0\b0  The object structure for 
\i oscil~\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 oscil_class = class_new("oscil~", (method)oscil_new, \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 		(method)dsp_free, sizeof(t_oscil), 0,A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.23
\f0\b0  The class instantiation call for 
\i oscil~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 void *oscil_new(t_symbol *s, short argc, t_atom *argv);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.24
\f0\b0  The function prototype for the new instance routine\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page union word		/* union for packing any above datum */\
\{\
  long w_long;\
  float w_float;\
  struct symbol *w_sym;\
  struct object *w_obj;\
\};\
\pard\pardeftab720\ri0\ql\qnatural

\f5 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1 \cf0 typedef struct atom	/* and an atom which is a typed datum */\
\{\
  short a_type;		/* from the above defs */\
  union word a_w;\
\} t_atom, Atom;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.25
\f0\b0  Max/MSP type definitions for 
\f1\fs20 word
\f0\fs24  and 
\f1\fs20 atom\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  1 void *oscil_new(t_symbol *s, short argc, t_atom *argv)
\fs20 \

\fs18  2 \{
\fs20 \

\fs18  3 	float init_freq; 
\fs20 \

\fs18  4 	t_oscil *x = (t_oscil *)object_alloc(oscil_class);
\fs20 \

\fs18  5 	dsp_setup((t_pxobject *)x,1);
\fs20 \

\fs18  6 	outlet_new((t_pxobject *)x, "signal");
\fs20 \

\fs18  7 	init_freq = 440.0;
\fs20 \

\fs18  8 	x->table_length = 8192;
\fs20 \

\fs18  9 	x->bl_harms = 10;
\fs20 \

\fs18 10 	x->waveform = gensym(OSCIL_DEFAULT_WAVEFORM);
\fs20 \

\fs18 11 	atom_arg_getfloat(&init_freq,0,argc,argv);
\fs20 \

\fs18 12 	atom_arg_getlong(&x->table_length,1,argc,argv);
\fs20 \

\fs18 13 	atom_arg_getsym(&x->waveform,2,argc,argv);
\fs20 \

\fs18 14 	atom_arg_getlong(&x->bl_harms,3,argc,argv);
\fs20 \

\fs18 15 	if(fabs(init_freq) > 1000000)\{
\fs20 \

\fs18 16 		init_freq = OSCIL_DEFAULT_FREQUENCY;
\fs20 \

\fs18 17 	\}
\fs20 \

\fs18 18 	if(x->table_length < 4 || x->table_length > OSCIL_MAX_TABLESIZE)\{
\fs20 \

\fs18 19 		x->table_length = OSCIL_DEFAULT_TABLESIZE;
\fs20 \

\fs18 20 	\}
\fs20 \

\fs18 21 	if(x->bl_harms < 0 || x->bl_harms > OSCIL_MAX_HARMS)\{
\fs20 \

\fs18 22 		x->bl_harms = OSCIL_DEFAULT_HARMS;
\fs20 \

\fs18 23 	\}
\fs20 \

\fs18 24 	x->twopi = 8.0 * atan(1.0);
\fs20 \

\fs18 25 	x->piotwo = 2. * atan(1.0);
\fs20 \

\fs18 26 	x->wavetable_bytes = x->table_length * sizeof(float);
\fs20 \

\fs18 27 	x->wavetable = (float *) sysmem_newptr(x->wavetable_bytes);
\fs20 \

\fs18 28 	x->amplitude_bytes = OSCIL_MAX_HARMS*sizeof(float);
\fs20 \

\fs18 29 	x->amplitudes = (float *)sysmem_newptr(x->amplitude_bytes);
\fs20 \

\fs18 30 	x->phase = 0;
\fs20 \

\fs18 31 	x->sr = sys_getsr(); 
\fs20 \

\fs18 32 	x->si_factor = (float) x->table_length / x->sr;
\fs20 \

\fs18 33 	x->si = init_freq * x->si_factor;
\fs20 \

\fs18 34 	x->amplitudes[0] = 0.0; 
\fs20 \

\fs18 35 	x->amplitudes[1] = 1.0; 
\fs20 \

\fs18 36 	x->harmonic_count = 2;
\fs20 \

\fs18 37 	oscil_build_waveform(x);
\fs20 \

\fs18 38 	post("oscil~: freq:%f length:%d harms:%d waveform:%s", 
\fs20 \

\fs18 	init_freq, x->table_length, x->bl_harms, x->waveform->s_name);
\fs20 \

\fs18 39 	return x;
\fs20 \

\fs18 40 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________
\f0\i\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\i0\b \cf0 Figure 5.26
\f0  
\b0 The new instance routine for 
\i oscil~\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs18 \cf0  1 void oscil_build_waveform(t_oscil *x) \{
\fs20 \

\fs18  2 	float rescale;
\fs20 \

\fs18  3 	int i, j;
\fs20 \

\fs18  4 	float max;
\fs20 \

\fs18  5 	float *wavetable = x->wavetable;
\fs20 \

\fs18  6 	float *amplitudes = x->amplitudes;
\fs20 \

\fs18  7 	int partial_count = x->harmonic_count + 1; 
\fs20 \

\fs18  8 	int table_length = x->table_length;
\fs20 \

\fs18  9 	float twopi = x->twopi;
\fs20 \

\fs18 10 	if(partial_count < 1)\{
\fs20 \

\fs18 11 		error("no harmonics specified, waveform not created.");
\fs20 \

\fs18 12 		return;
\fs20 \

\fs18 13 	\}
\fs20 \

\fs18 14 	max = 0.0;
\fs20 \

\fs18 15 	for(i = 0; i < partial_count; i++)\{
\fs20 \

\fs18 16 		max += fabs(amplitudes[i]);
\fs20 \

\fs18 17 	\}
\fs20 \

\fs18 18 	if(! max)\{
\fs20 \

\fs18 19 		error("all zero function, waveform not created.");
\fs20 \

\fs18 20 		return; 
\fs20 \

\fs18 21 	\}
\fs20 \

\fs18 22 	for(i = 0; i < table_length; i++)\{
\fs20 \

\fs18 23 		wavetable[i] = amplitudes[0];
\fs20 \

\fs18 24 	\}
\fs20 \

\fs18 25 	for(i = 1 ; i < partial_count; i++)\{
\fs20 \

\fs18 26 		if(amplitudes[i])\{
\fs20 \

\fs18 27 			for(j = 0; j < table_length; j++)\{
\fs20 \

\fs18 28 				wavetable[j] += amplitudes[i] * sin(twopi * 					((float)i * ((float)j/(float)table_length)));
\fs20 \

\fs18 29 			\}
\fs20 \

\fs18 30 		\}
\fs20 \

\fs18 31 	\}
\fs20 \

\fs18 32 	max = 0.0;
\fs20 \

\fs18 33 	for(i = 0; i < table_length / 2; i++)\{
\fs20 \

\fs18 34 		if(max < fabs(wavetable[i]))\{
\fs20 \

\fs18 35 			max = fabs(wavetable[i]) ;
\fs20 \

\fs18 36 		\}
\fs20 \

\fs18 37 	\}
\fs20 \

\fs18 38 	if(max == 0) \{
\fs20 \

\fs18 39 		post("oscil~: weird all zero error - exiting!");
\fs20 \

\fs18 40 		return;
\fs20 \

\fs18 41 	\}
\fs20 \

\fs18 42 	rescale = 1.0 / max;
\fs20 \

\fs18 43 	for(i = 0; i < table_length; i++)\{
\fs20 \

\fs18 44 		wavetable[i] *= rescale ;
\fs20 \

\fs18 45 	\}
\fs20 \

\fs18 46 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.27
\f0\b0  The waveform-building function for 
\i oscil~\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 t_int *oscil_perform(t_int *w)\
 2 \{\
 3 	t_oscil *x = (t_oscil *) (w[1]);\
 4 	float *frequency = (t_float *)(w[2]);\
 5 	float *out = (t_float *)(w[3]);\
 6 	int n = w[4];\
 7 	float si_factor = x->si_factor;\
 8 	float si = x->si ;\
 9 	float phase = x->phase;\
10 	int table_length = x->table_length;\
11 	float *wavetable = x->wavetable;\
12 	long iphase;\
13 	while (n--) \{\
14 		si = *frequency++ * si_factor;\
15 		iphase = trunc(phase);\
16 		*out++ = wavetable[iphase];\
17 		phase += si;\
18 		while(phase >= table_length) \{\
19 			phase -= table_length;\
20 		\}\
21 		while(phase < 0) \{\
22 			phase += table_length;\
23 		\}\
24 	\}\
25 	x->phase = phase;\
26 	return w + 5;\
27 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.28
\f0\b0  First version of the perform routine for 
\i oscil~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 void oscil_assist(t_oscil *x, void *b, long msg, long arg, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 char *dst)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	if (msg == ASSIST_INLET) \{\
 4 		sprintf(dst,"(signal/float) Frequency");\
 5 	\} \
 6 	else if (msg == ASSIST_OUTLET) \{\
 7 		sprintf(dst,"(signal) Output");\
 8 	\}\
 9 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.30
\f0\b0  The assist method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f5\fs20 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1 \cf0 1 void oscil_float(t_oscil *x, double f) \{\
2   x->si = f * x->si_factor;\
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.31
\f0\b0  The float method\
\page   
\f1\fs20 1 t_int *oscil_perform2(t_int *w)\
 2 \{\
 3 	t_oscil *x = (t_oscil *) (w[1]);\
 4 	float *out = (t_float *)(w[2]);\
 5 	int n = w[3];	\
 6 	float si = x->si;\
 7 	float phase = x->phase;\
 8 	int table_length = x->table_length;\
 9 	float *wavetable = x->wavetable;\
10 	long iphase;\
11 	while (n--) \{\
12 		iphase = trunc(phase);\
13 		*out++ = wavetable[iphase];\
14 		phase += si;\
15 		while(phase >= table_length) \{\
16 			phase -= table_length;\
17 		\}\
18 		while(phase < 0) \{\
19 			phase += table_length;\
20 		\}\
21 	\}\
22 	x->phase = phase;\
23 	return w + 4;\
24 \}\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.32
\f0\b0  The perform routine for when signal is not connected to the inlet\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_dsp(t_oscil *x, t_signal **sp, short *count)\
 2 \{\
 3 	if(count[0]) \{\
 4 		dsp_add(oscil_perform, 4, x, sp[0]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[1]->s_vec,sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  5 	\} \
 6 	else \{\
 7 		dsp_add(oscil_perform2, 3, x, sp[1]->s_vec, sp[0]->s_n);\
 8 	\}\
 9 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.33
\f0\b0  Selecting the appropriate perform routine \
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 if(x->sr != sp[0]->s_sr)\{\
2 	x->si *= x->sr / sp[0]->s_sr; // rescale sampling increment\
3 	x->sr = sp[0]->s_sr; // assign new sampling rate\
4 	x->si_factor = (float) x->table_length / x->sr; \
5 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.34
\f0\b0  Adjusting the sampling increment when the sampling rate changes\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void oscil_sine(t_oscil *x)\
2 \{\
3   x->amplitudes[0] = 0.0;\
4   x->amplitudes[1] = 1.0;\
5   x->harmonic_count = 2;\
6   oscil_build_waveform(x);\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.35
\f0\b0  The method to build a sine wave\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
1 void oscil_triangle(t_oscil *x)\
 2 \{\
 3   int i;\
 4   float sign = 1.0;\
 5   x-> amplitudes [0] = 0.0; // DC\
 6   x->harmonic_count = x->bl_harms;\
 7   for( i = 1 ; i < x->bl_harms; i += 2 )\{\
 8     x->amplitudes[i] = sign * 1.0/((float)i * (float)i);\
 9     x->amplitudes[i + 1] = 0.0;\
10     sign *= -1;\
11   \}\
12   oscil_build_waveform(x);\
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.38
\f0\b0  The triangle wave method\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
 \
 \
\page  1 void oscil_sawtooth(t_oscil *x)\
 2 \{\
 3   int i;\
 4   float sign = 1.0;\
 5 \
 6   x->amplitudes[0] = 0.0;\
 7   x->harmonic_count = x->bl_harms;\
 8   for(i = 1 ; i < x->bl_harms; i++)\{\
 9     x->amplitudes[i] = sign * 1.0/(float)i;\
10     sign *= -1. ;\
11   \}\
12   oscil_build_waveform(x);\
13 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.40
\f0\b0  The sawtooth wave method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_square(t_oscil *x)\
 2 \{\
 3   int i;\
 4   x-> amplitudes [0] = 0.0;\
 5   x->harmonic_count = x->bl_harms;\
 6   for(i = 1 ; i < x->bl_harms; i += 2)\{\
 7     x->amplitudes[i] = 1.0/(float)i;\
 8     x->amplitudes[i + 1] = 0.0;\
 9   \}\
10   oscil_build_waveform(x);\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.42
\f0\b0  The square wave method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_pulse(t_oscil *x)\
 2 \{\
 3   int i;\
 4   x->amplitudes[0] = 0.0;\
 5   x->harmonic_count = x->bl_harms;\
 6   for(i = 1 ; i < x->bl_harms; i++)\{\
 7     x->amplitudes[i] = 1.0;\
 8   \}\
 9   oscil_build_waveform(x);\
10 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.43
\f0\b0  The pulse wave method\
\
\
\
\
\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 t_class *c;\
2 oscil_class = class_new("oscil~", (method)oscil_new, \
3 		(method)oscil_free, sizeof(t_oscil), 0,A_GIMME,0);\
4 c = oscil_class;\
5 class_addmethod(c,(method)oscil_sine, "sine", 0);\
6 class_addmethod(c,(method)oscil_triangle, "triangle", 0);\
7 class_addmethod(c,(method)oscil_square, "square", 0);\
8 class_addmethod(c,(method)oscil_sawtooth, "sawtooth", 0);\
9 class_addmethod(c,(method)oscil_pulse, "pulse", 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.44
\f0\b0  Waveform generation method bindings\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_list (t_oscil *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	short i;\
 4 	int harmonic_count = 0;\
 5 	float *amplitudes = x->amplitudes;\
 6 	for (i=0; i < argc; i++) \{\
 7 		amplitudes[harmonic_count++] = atom_getfloat(argv + i);\
 8 	\}  \
 9 	x->harmonic_count = harmonic_count;\
10 	oscil_build_waveform(x);\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.46
\f0\b0  A list method to set the harmonic weightings\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(c,(method)oscil_list, "list", A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.47
\f0\b0  Binding the \'93list\'94 message\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  
\fs20 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\page  
\fs18 1 if (x->waveform == gensym("sine")) \{
\fs20 \

\fs18  2 		oscil_sine(x);
\fs20 \

\fs18  3 \} 
\fs20 \

\fs18  4 else if (x->waveform == gensym("triangle")) \{
\fs20 \

\fs18  5 		oscil_triangle(x);
\fs20 \

\fs18  6 \} 
\fs20 \

\fs18  7 else if (x->waveform == gensym("square")) \{
\fs20 \

\fs18  8 		oscil_square(x);
\fs20 \

\fs18  9 \} 
\fs20 \

\fs18 10 else if (x->waveform == gensym("sawtooth")) \{
\fs20 \

\fs18 11 		oscil_sawtooth(x);
\fs20 \

\fs18 12 \} 
\fs20 \

\fs18 13 else if (x->waveform == gensym("pulse")) \{
\fs20 \

\fs18 14 		oscil_pulse(x);
\fs20 \

\fs18 15 \} 
\fs20 \

\fs18 16 else \{ 
\fs20 \

\fs18 17 		error("%s not a legal waveform - using sine wave instead", 
\fs20 \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural

\fs18 \cf0 x->waveform->s_name);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 18 		oscil_sine(x);
\fs20 \

\fs18 19 \}
\fs20 \
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.49
\f0\b0  Selecting and generating the user-selected initial waveform\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float *old_wavetable;\
short dirty;
\f4\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f0 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.51
\f0\b0  New object structure components to facilitate waveform transitions\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->dirty = 0;\
x->old_wavetable = (float *) sysmem_newptr(x->wavetable_bytes);
\f4\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f0 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.52
\f0\b0  Initializing components needed to transition between waveforms\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_build_waveform(t_oscil *x) \{\
 2 	// some variable declarations omitted here\
 3 	float *wavetable = x->wavetable;\
 4 	float *old_wavetable = x->old_wavetable;\
 5 	\
 6 	// copy current wave table to old wave table\
 7 	for(i = 0; i < table_length ; i++)\{\
 8 		old_wavetable[i] = wavetable[i];\
 9 	\}\
10 	x->dirty = 1;\
11 	// new wave table generation omitted here\
12 	x->dirty = 0; \
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.53
\f0\b0  Additional code for the wavetable building method\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 memcpy(old_wavetable, wavetable, table_length * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.54
\f0\b0  A more compact way to copy blocks of memory\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 t_int *oscil_perform(t_int *w)\
 2 \{\
 3 	// other variable declarations omitted\
 4 	float *old_wavetable = x->old_wavetable;\
 5 	// most of the existing code is omitted from this example\
 6 	while(n--)\
 7 		if(x->dirty)\{\
 8 			*out++ = old_wavetable[iphase];\
 9 		\} else \{\
10 			*out++ = wavetable[iphase];	\
11 		\}\
12 	\}\
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.55
\f0\b0  Revised code in the perform routines\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 crossfade_samples = crossfade_duration * srate / 1000.0;\
2 crossfade_countdown = crossfade_samples;\
3 \
4 while(crossfade_countdown--)\{\
5   fraction = crossfade_countdown/crossfade_samples; \
6   output = fraction * old_sample + (1 \'96 fraction) * new_sample;\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.56
\f0\b0  A sketch of the crossfade code\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 output = new_sample + fraction * (old_sample \'96 new_sample);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.57
\f0\b0  A more efficient interpolation algorithm \
\
\

\f4 \
\
\
\
\
\
\
  \
\page   
\f1\fs20 1 int iphase;\
 2 // code omitted\
 3 iphase = phase;\
 4 \
 5 if( crossfade_countdown )\{\
 6   fraction = (float)xfade_countdown/(float)xfade_samples;\
 7   *out++ = wavetable[iphase] +\
 8   fraction * (old_wavetable[iphase] - wavetable[iphase]);\
 9  --xfade_countdown;\
10 \}\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.58
\f0\b0  Implementing the crossfade in the perform routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 if( xfade_countdown )\{\
2   fraction = PIOVERTWO * \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 (float)xfade_countdown/(float)xfade_samples;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 3   *out++ = sin(fraction) * old_wavetable[iphase] + cos(fraction) * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 wavetable[iphase];\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 4   --xfade_countdown;\
5 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.59
\f0\b0  A sketch of the equal-power crossfade code\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #define OSCIL_NOFADE 0\
#define OSCIL_LINEAR 1\
#define OSCIL_POWER 2\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.61
\f0\b0  Crossfade type constants\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float xfade_duration;\
int xfade_samples;\
int xfade_countdown;\
short xfadetype;  \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\b \cf0 Figure 5.62
\b0  New crossfade components for the object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->xfade_countdown = 0;\
2 x->xfade_duration = 50. ;\
3 x->xfade_samples = x->xfade_duration * x->sr / 1000.0;\
4 x->xfadetype = OSCIL_LINEAR;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.63
\f0\b0  Initializations in the new instance routine\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 if(x->fadetype)\{\
2   x->fade_countdown = x->fade_samples;\
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.64
\f0\b0  Initiate a crossfade when the fade type is non-zero\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 short firsttime;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.65
\f0\b0  The initialization flag component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->firsttime = 1;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.66
\f0\b0  Set the initialization flag in the new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->firsttime = 0;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.67
\f0\b0  Permanently set the initialization flag to zero\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 if(x->xfadetype  && ! x->firsttime)\{\
2   x->xfade_countdown = x->xfade_samples; \
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.68
\f0\b0  Revised countdown reset code\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
 
\fs18 1 t_int *oscil_perform(t_int *w)
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  2 \{
\fs20 \

\fs18  3 	t_oscil *x = (t_oscil *) (w[1]);
\fs20 \

\fs18  4 	float *frequency = (t_float *)(w[2]);
\fs20 \

\fs18  5 	float *out = (t_float *)(w[3]);
\fs20 \

\fs18  6 	int n = w[4];
\fs20 \

\fs18  7 	float si_factor = x->si_factor;
\fs20 \

\fs18  8 	float si = x->si;
\fs20 \

\fs18  9 	float phase = x->phase;
\fs20 \

\fs18 10 	int table_length = x->table_length;
\fs20 \

\fs18 11 	float *wavetable = x->wavetable;
\fs20 \

\fs18 12 	float *old_wavetable = x->old_wavetable;
\fs20 \

\fs18 13 	int xfade_countdown = x->xfade_countdown;
\fs20 \

\fs18 14 	int xfade_samples = x->xfade_samples;
\fs20 \

\fs18 15 	short xfadetype = x->xfadetype;
\fs20 \

\fs18 16 	float piotwo = x->piotwo;
\fs20 \

\fs18 17 	long iphase;
\fs20 \

\fs18 18 	float fraction;	
\fs20 \

\fs18 19 	while (n--) \{
\fs20 \

\fs18 20 		si = *frequency++ * si_factor;
\fs20 \

\fs18 21 		iphase = trunc(phase);
\fs20 \

\fs18 22 		if(x->dirty)\{
\fs20 \

\fs18 23 			*out++ = old_wavetable[iphase];
\fs20 \

\fs18 24 		\} 
\fs20 \

\fs18 25 		else if (xfade_countdown > 0) \{ 
\fs20 \

\fs18 26 			fraction = 
\fs20 \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural

\fs18 \cf0 (float)xfade_countdown--/(float)xfade_samples;
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 27 			if(xfadetype == OSCIL_LINEAR)\{
\fs20 \

\fs18 28 				*out++ = wavetable[iphase] + fraction * 
\fs20 \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural

\fs18 \cf0 (old_wavetable[iphase] - wavetable[iphase]);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 29 			\} 
\fs20 \

\fs18 30 			else if (xfadetype == OSCIL_POWER) \{
\fs20 \

\fs18 31 				fraction *= piotwo; 
\fs20 \

\fs18 32 				*out++ = sin(fraction) * old_wavetable[iphase]
\fs20 \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural

\fs18 \cf0 + cos(fraction) * wavetable[iphase];
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 33 			\}
\fs20 \

\fs18 34 		\}	
\fs20 \

\fs18 35 		else \{
\fs20 \

\fs18 36 			*out++ = wavetable[iphase];	
\fs20 \

\fs18 37 		\}	
\fs20 \

\fs18 38 		phase += si;
\fs20 \

\fs18 39 		while(phase >= table_length) \{
\fs20 \

\fs18 40 			phase -= table_length;
\fs20 \

\fs18 41 		\}
\fs20 \

\fs18 42 		while(phase < 0) \{
\fs20 \

\fs18 43 			phase += table_length;
\fs20 \

\fs18 44 		\}
\fs20 \

\fs18 45 	\}
\fs20 \

\fs18 46 	x->xfade_countdown = xfade_countdown;
\fs20 \

\fs18 47 	x->phase = phase;
\fs20 \

\fs18 48 	return w + 5;
\fs20 \

\fs18 49 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.69
\f0\b0  The perform routine with crossfades implemented\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \page  1 void oscil_fadetime (t_oscil *x, double fade_ms)\
 2 \{\
 3   if(fade_ms < 0.0 || fade_ms > 600000.0)\{\
 4     error("%f is not a legal fade time", fade_ms);\
 5     fade_ms = 50.;\
 6   \}\
 7   x->xfade_duration = fade_ms;\
 8   x->xfade_samples = x->xfade_duration * x->sr / 1000.0;\
 9 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.70
\f0\b0  The fadetime method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(oscil_class,(method)oscil_fadetime, "fadetime",\
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 A_FLOAT, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.71
\f0\b0  Binding the fadetime method in 
\f1\fs20 main()\
\
\
\
 1 void oscil_fadetype(t_oscil *x, long ftype)\
 2 \{\
 3 \
 4   if(ftype < 0 || ftype > 2) \{\
 5     error("unknown type of fade, selecting no fade");\
 6     ftype = 0;\
 7   \}\
 8   x->xfadetype = (short)ftype;\
 9 \}\
\
_____________________________________________________________________
\f0\fs24 \

\f3\b Figure 5.72
\f0\b0  The fadetype method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(c,(method)oscil_fadetype,"fadetype",A_LONG, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.73
\f0\b0  Binding the fadetype method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void oscil_free(t_oscil *x)\
2 \{\
3   dsp_free((t_pxobject *) x)\
4   sysmem_freeptr(x->wavetable);\
5   sysmem_freeptr(x->old_wavetable);\
6   sysmem_freeptr(x->amplitudes);\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.77
\f0\b0  The custom free memory routine\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 \page \pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 oscil_class = class_new("oscil~", (method)oscil_new, \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 		(method)oscil_free, sizeof(t_oscil), 0,A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.78
\f0\b0  Replacing 
\f1\fs20 dsp_free()
\f0\fs24  with 
\f1\fs20 oscil_free()
\f0\fs24  in the class definition\
\
\
\
\pard\tx480\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #include "m_pd.h"\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 #include "math.h"\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.79
\f0\b0  Pd header files\
\
\
\
\pard\tx480\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _oscil\
\{\
	t_object obj; // required for all Pd objects\
	t_float x_f; // internally convert floats to signals\
	// the rest is identical to Max/MSP structure\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \} t_oscil;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.80
\f0\b0  The Pd object structure\
\
\
\
\pard\tx480\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void oscil_fadetime (t_oscil *x, t_floatarg fade_ms);\
void oscil_fadetype(t_oscil *x, t_floatarg ftype);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.81
\f0\b0  Revised function prototypes with floating point arguments\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void oscil_fadetype(t_oscil *x, t_floatarg ftype)\
2 \{\
3 	if(ftype < 0 || ftype > 2) \{\
4 		error("unknown type of fade, selecting no fade");\
5 		ftype = 0;\
6 	\}\
7 	x->xfadetype = (short) ftype;\
8 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.82
\f0\b0  The revised 
\f1\fs20 oscil_fadetype()
\f0\fs24  method\
\
\
\
\
\
\page   
\f1\fs20 1 void oscil_tilde_setup (void)\
 2 \{\
 3 	t_class * c;\
 4 	oscil_class = class_new(gensym("oscil~"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (t_newmethod) oscil_new, (t_method)oscil_free, \
sizeof(t_oscil), 0, A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  5 	CLASS_MAINSIGNALIN(oscil_class, t_oscil, x_f);\
 6 	c = oscil_class;\
 7 	class_addmethod(c,(t_method)oscil_dsp, gensym("dsp"),0);\
 8 	class_addmethod(c,(t_method)oscil_mute, gensym("mute"),\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_FLOAT, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  9 	class_addmethod(c,(t_method)oscil_sine, gensym("sine"), 0);\
10 	class_addmethod(c,(t_method)oscil_triangle,\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("triangle"), 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	class_addmethod(c,(t_method)oscil_square, gensym("square"), 0);\
12 	class_addmethod(c,(t_method)oscil_sawtooth, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("sawtooth"), 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 13 	class_addmethod(c,(t_method)oscil_pulse, gensym("pulse"), 0);\
14 	class_addmethod(c,(t_method)oscil_list, gensym("list"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 15 	class_addmethod(c,(t_method)oscil_fadetime, gensym("fadetime"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_FLOAT, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 16 	class_addmethod(c,(t_method)oscil_fadetype, gensym("fadetype"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_FLOAT, 0); \
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 17 	
\f6\fs22 	
\f1\fs20 post("oscil~ from \\"Designing Audio Objects\\" by Eric Lyon");
\f6\fs22 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.83
\f0\b0  The class definition routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 t_oscil *x = (t_oscil *)object_alloc(oscil_class);\
2 dsp_setup((t_pxobject *)x,1);\
3 outlet_new((t_pxobject *)x, "signal");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.84
\f0\b0  Max/MSP instantiation code for the object and its inlets/outlets\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 t_oscil *x = (t_oscil *) pd_new(oscil_class);\
2 outlet_new(&x->obj, gensym("signal"));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.85
\f0\b0  The Pd equivalent to the Max/MSP instantiation code\
\
\
\
\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void oscil_dsp(t_oscil *x, t_signal **sp)\
 2 \{\
 3 	\
 4 	if(x->sr != sp[0]->s_sr)\{\
 5 		x->si *= x->sr / sp[0]->s_sr; \
 6 		x->sr = sp[0]->s_sr; \
 7 		x->si_factor = (float) x->table_length / x->sr; \
 8 		x->xfade_samples = x->xfade_duration * x->sr / 1000.0;\
 9 	\}	\
10 	dsp_add(oscil_perform, 4, x, sp[0]->s_vec, sp[1]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.86
\f0\b0  The Pd dsp method for 
\i oscil~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 x->wavetable = (float *) getbytes(x->wavetable_bytes);\
2 x->amplitudes = (float *)getbytes(x->amplitude_bytes);\
3 x->old_wavetable = (float *) getbytes(x->wavetable_bytes);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________
\f0\i\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\i0\b \cf0 Figure 5.87
\f0\b0  Memory allocation calls for Pd\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void oscil_free(t_oscil *x)\
2 \{\
3 	freebytes(x->wavetable, x->wavetable_bytes);\
4 	freebytes(x->old_wavetable, x->wavetable_bytes);\
5 	freebytes(x->amplitudes, x->amplitude_bytes);\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 5.88
\f0\b0  The free function for Pd\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _retroseq\
\{\
  t_pxobject x_obj;\
  float *sequence; // store sequence of frequency values\
  int sequence_length; // length of sequence\
  int duration_samples; // duration of a note in samples\
  float note_duration_ms; // duration of a note in milliseconds\
  int counter; // countdown the note in samples\
  int position; // position in sequence\
  float sr; // sampling rate\
\} t_retroseq;\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.1
\f0\b0  The 
\i retroseq~
\i0  object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_dsp(t_retroseq *x, t_signal **sp, short *count)\
2 \{\
3   dsp_add(retroseq_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.2
\f0\b0  The 
\i retroseq~
\i0  dsp method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #define MAX_SEQUENCE 1024\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.3
\f0\b0  Defining the maximum sequence length\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \
\page  1 void *retroseq_new(void)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *)object_alloc(retroseq_class);\
 4 	dsp_setup((t_pxobject *)x,0);\
 5 	outlet_new((t_pxobject *)x, "signal");\
 6 	x->sr =  sys_getsr(); \
 7 	if(!x->sr)\{\
 8 		x->sr = 44100.0; \
 9 	\}\
10 	x->sequence = \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 (float *) sysmem_newptr(MAX_SEQUENCE * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	if(x->sequence == NULL)\{\
12 		post("retroseq: memory allocation fail");\
13 		return NULL;\
14 	\}\
15 	x->position = 0;\
16 	x->note_duration_ms = 1000.0;\
17 	x->duration_samples = x->note_duration_ms * x->sr / 1000.;	\
18 	x->counter = x->duration_samples;	\
19 	x->sequence_length = 3;\
20 	x->sequence[0] = 440;\
21 	x->sequence[1] = 550;\
22 	x->sequence[2] = 660;	\
23 	return x;\
24 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f3\b\fs24 Figure 6.4
\f0\b0  The new instance routine for 
\i retroseq~
\i0 \
\pard\pardeftab720\ri0\ql\qnatural

\i \cf0 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 void retroseq_free(t_retroseq *x)\
2 \{\
3 	dsp_free((t_pxobject *)x);\
4 	sysmem_freeptr(x->sequence);\
5 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.5
\f0\b0  The free function for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 while(n--)\{\
2   counter--;\
3   *out++ = sequence[position];\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.6
\f0\b0  Basic sequencing code\
\
\page   
\f1\fs20 1 t_int *retroseq_perform(t_int *w)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *) (w[1]);\
 4 	float *out = (t_float *)(w[2]);\
 5 	int n = w[3];\
 6 	int sequence_length = x->sequence_length;\
 7 	int duration_samples = x->duration_samples;\
 8 	int counter = x->counter;\
 9 	int position = x->position;\
10 	float *sequence = x->sequence;\
11 	\
12 	while(n--)\{\
13 		if(! counter--)\{\
14 			++position;\
15 			if(position >= sequence_length)\{\
16 				position = 0;\
17 			\}\
18 			counter = duration_samples;\
19 		\}\
20 		*out++ = sequence[position];\
21 	\}\
22 	x->counter = counter;\
23 	x->position = position;\
24 	return w + 4;\
25 \}\
_____________________________________________________________________
\f0\fs24 \

\f3\b Figure 6.7
\f0\b0  The perform routine for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 void *retroseq_new(void);\
t_int *retroseq_perform(t_int *w);\
void retroseq_dsp(t_retroseq *x, t_signal **sp, short *count);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.8
\f0\b0  Function prototypes for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 int main(void)\
 2 \{\
 3 	t_class *c;\
 4 	retroseq_class = class_new("retroseq~", (method)retroseq_new, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (method)retroseq_free, sizeof(t_retroseq), 0,A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  5 	c = retroseq_class;\
 6 	class_addmethod(c, (method)retroseq_dsp, "dsp", A_CANT, 0);\
 7 	class_dspinit(c);\
 8 	class_register(CLASS_BOX, c);\
 9 	post("retroseq~: from \\"Designing Audio Objects\\" by Eric Lyon");\
10 	return 0;\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.9
\f0\b0  The initialization routine\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
typedef struct _retroseq\
\{\
  t_pxobject x_obj;\
  float *sequence; // store sequence of frequency values\
  long sequence_length; // length of sequence\
  long duration_samples; // duration of a note in samples\
  float note_duration_ms; // duration of a note in milliseconds\
  long counter; // countdown the note in samples\
  long position; // position in sequence\
  float sr; // sampling rate\
  float current_value; // stores current frequency (or whatever)\
\} t_retroseq;\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.11
\f0\b0  The revised object structure for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 t_int *retroseq_perform(t_int *w)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *) (w[1]);\
 4 	float *out = (t_float *)(w[2]);\
 5 	int n = w[3];\
 6 	long sequence_length = x->sequence_length;\
 7 	long duration_samples = x->duration_samples;\
 8 	long counter = x->counter;\
 9 	long position = x->position;\
10 	float *sequence = x->sequence;\
11 	float current_value = x->current_value;\
12 	\
13 	while(n--)\{\
14 		if(! counter--)\{\
15 			++position;\
16 			if(position >= sequence_length)\
17 				position = 0;\
18 			counter = duration_samples;\
19 			current_value = sequence[position];\
20 		\}\
21 		*out++ = current_value;\
22 	\}\
23 	x->current_value = current_value;\
24 	x->counter = counter;\
25 	x->position = position;	\
26 	return w + 4;\
27 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.12
\f0\b0  The revised perform routine for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page  1 void *retroseq_new(void)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *)object_alloc(retroseq_class);\
 4 	dsp_setup((t_pxobject *)x,0);\
 5 	outlet_new((t_pxobject *)x, "signal");\
 6 	x->sr =  sys_getsr(); // will recheck in dsp method\
 7 	if(!x->sr)\{\
 8 		x->sr = 44100.0; // for safety\
 9 	\}\
10 	x->sequence = (float *) sysmem_newptr(MAX_SEQUENCE * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	if(x->sequence == NULL)\{\
12 		post("retroseq: memory allocation fail");\
13 		return NULL;\
14 	\}\
15 	x->position = 0 ;\
16 	x->note_duration_ms = 250.0;\
17 	x->duration_samples = x->note_duration_ms * x->sr / 1000. ;\
18 	x->counter = x->duration_samples;\
19 	x->sequence_length = 3;\
20 	x->sequence[0] = 440;\
21 	x->sequence[1] = 550;\
22 	x->sequence[2] = 660;\
23 	x->current_value = x->sequence[0];\
24 	return x;\
25 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.13
\f0\b0  The revised new instance routine for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 void retroseq_list(t_retroseq *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	int i;\
 4 	float *sequence = x->sequence;\
 5 	if( argc < 2 )\{\
 6 		post("retroseq: sequence must have at least two members");\
 7 		return;\
 8 	\}	\
 9 	x->sequence_length = argc;\
10 	for (i=0; i < argc; i++) \{\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sequence[i] = atom_getfloatarg(i,argc,argv);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 12 	\}\
13 	x->position = x->sequence_length - 1;\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\b \cf0 Figure 6.14
\b0  The list processing method for reading sequences\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(c,(method)retroseq_list,"list",A_GIMME,0);
\f0\fs24 \

\f1\fs20 \
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\b \cf0 Figure 6.15
\b0  Binding the list method\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
 1 void retroseq_dsp(t_retroseq *x, t_signal **sp, short *count)\
 2 \{\
 3 	if( x->sr != sp[0]->s_sr )\{\
 4 		if(! sp[0]->s_sr)\{\
 5 			error("retroseq: zero sampling rate!");\
 6 			return;\
 7 		\}\
 8 		x->counter *= x->sr / sp[0]->s_sr; // rescale countdown\
 9 		x->sr = sp[0]->s_sr; // assign new sampling rate\
10 		x->duration_samples = x->note_duration_ms * 0.001 * \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->sr; \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	\}	\
12 	dsp_add(retroseq_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);\
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.16
\f0\b0  Adjusting to changes in the sampling rate inside the dsp method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->note_duration_ms = 1000. * 60.0 / tempo;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.18
\f0\b0  Calculating the duration in milliseconds from the tempo\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _retroseq\
\{\
  t_pxobject x_obj;\
  float *sequence; // store sequence of frequency values\
  int sequence_length; // length of sequence\
  int duration_samples; // duration of a note in samples\
  float note_duration_ms; // duration of a note in milliseconds\
  int counter; // countdown the note in samples\
  int position; // position in sequence\
  float sr; // sampling rate\
  float current_value; // stores current frequency (or whatever)\
  float tempo; // tempo in BPM\
\} t_retroseq;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.19
\f0\b0  The revised object structure with new tempo-related components\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_tempo(t_retroseq *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	float t;\
 4 	if(argc == 1)\{\
 5 		t = atom_getfloatarg(0, argc,argv);\
 6 	\} else \{\
 7 		return;\
 8 	\}\
 9 	if( t <= 0 )\{\
10 		error("retroseq~: tempo must be greater than zero");\
11 		return;\
12 	\}\
13 	x->tempo = t;\
14    x->note_duration_ms = 0.25 * 60000.0 /  x->tempo ;\
15    x->duration_samples = x->note_duration_ms * x->sr / 1000.0;\
16 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.20
\f0\b0  The 
\i retroseq~
\i0  tempo method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(c, (method)retroseq_tempo, "tempo", A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.21
\f0\b0  Binding the tempo method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->tempo = 60.0;\
2 x->note_duration_ms = 60000.0 / x->tempo;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.22
\f0\b0  Initializing the tempo to 60 bpm\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_tempo(t_retroseq *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	if(argc >= 1)\{\
 4 		t = atom_getfloatarg(0, argc,argv);\
 5 	\} \
 6 	else \{\
 7 		return;\
 8 	\}\
 9 	if( t <= 0 )\{\
10 		error("retroseq~: tempo must be greater than zero");\
11 		return;\
12 	\}\
13 	x->tempo = t;\
14 	x->note_duration_ms = 0.25 * 60000.0 /  x->tempo ;\
15 	x->duration_samples = x->note_duration_ms * x->sr / 1000.0;\
16 	if(x->counter > x->duration_samples)\{\
17 		x->counter = x->duration_samples;\
18 	\}\
19 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.24
\f0\b0  Making tempo changes instantaneous\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _retroseq\
\{\
  t_pxobject x_obj;\
  float *f_sequence; // store sequence of frequency values\
  float *d_sequence; // store sequence of duration values\
  int f_sequence_length; // length of frequency sequence\
  int d_sequence_length; // length of duration sequence\
  int counter; // countdown the note in samples\
  int f_position; // position in frequency sequence\
  int d_position; // position in duration sequence\
  float sr; // sampling rate\
  float current_value; // stores current frequency (or whatever)\
  int current_duration_samples; // current duration in samples\
  float duration_factor; // get samples from duration, sr and tempo\
  float tempo; // tempo in BPM\
\} t_retroseq;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.26
\f0\b0  The object structure modified to accept a duration sequence\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void *retroseq_new(t_symbol *s, short argc, t_atom *argv)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *)object_alloc(retroseq_class);\
 4 	dsp_setup((t_pxobject *)x,0);\
 5 	outlet_new((t_pxobject *)x, "signal");\
 6 	x->sr =  sys_getsr(); // will recheck in dsp method\
 7 	if(!x->sr)\{\
 8 		x->sr = 44100.0; // for safety\
 9 	\}\
10 	x->f_sequence = \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (float *)sysmem_newptr(MAX_SEQUENCE*sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	x->d_sequence = \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (float *)sysmem_newptr(MAX_SEQUENCE*sizeof(float) );\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 12 	if(x->f_sequence == NULL || x->d_sequence == NULL)\{\
13 		post("retroseq: memory allocation fail");\
14 		return NULL;\
15 	\}\
16 	x->f_position = 0;\
17 	x->d_position = 0;\
18 	x->tempo = 60.0;\
19 	x->duration_factor = x->sr/1000.0 ; // default tempo is 60\
20 	x->f_sequence_length = 3;\
21 	x->d_sequence_length = 3;\
22 	x->f_sequence[0] = 440;\
23 	x->f_sequence[1] = 550;\
24 	x->f_sequence[2] = 660;\
25 	x->d_sequence[0] = 250;\
26 	x->d_sequence[1] = 125;\
27 	x->d_sequence[2] = 125;\
28 	x->current_value = x->f_sequence[0];\
29 	x->counter = x->d_sequence[0] * x->sr/ 1000.0 ;	\
30 	return x;\
31 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.27
\f0\b0  The revised new instance routine for 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page \pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  1 void retroseq_list(t_retroseq *x,t_symbol *msg,short argc,
\fs20 \
\pard\pardeftab720\fi720\ri0\ql\qnatural

\fs18 \cf0 t_atom *argv)
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  2 \{
\fs20 \

\fs18  3 	int i, j;
\fs20 \

\fs18  4 	float *f_sequence = x->f_sequence;
\fs20 \

\fs18  5 	float *d_sequence = x->d_sequence;
\fs20 \

\fs18  6 	
\fs20 \

\fs18  7 	if( argc % 2 )\{ // reject lists with odd number of members
\fs20 \

\fs18  8 		error("retroseq~: odd number of arguments!");
\fs20 \

\fs18  9 		return;
\fs20 \

\fs18 10 	\}
\fs20 \

\fs18 11 	if( argc < 2 )
\fs20 \

\fs18 12 		return;		
\fs20 \

\fs18 13 	x->f_sequence_length = argc / 2;
\fs20 \

\fs18 14 	x->d_sequence_length = argc / 2;
\fs20 \

\fs18 15 
\fs20 \

\fs18 16 	if(x->f_sequence_length >= MAX_SEQUENCE)\{
\fs20 \

\fs18 17 		error("retroseq~: sequence is too long");
\fs20 \

\fs18 18 		return;
\fs20 \

\fs18 19 	\} 		
\fs20 \

\fs18 20 	for (i=0, j=0; i < argc; i += 2, j++) \{
\fs20 \

\fs18 21 		atom_arg_getfloat(f_sequence+j, i, argc,argv);
\fs20 \

\fs18 22 		atom_arg_getfloat(d_sequence+j, i+1, argc,argv);
\fs20 \

\fs18 23 		if(d_sequence[j] <= 0)\{
\fs20 \

\fs18 24 			error("retroseq~: %f is an illegal duration value. Reset to 100 ms.",d_sequence[j] );
\fs20 \

\fs18 25 			d_sequence[j] = 100.0;
\fs20 \

\fs18 26 		\}
\fs20 \

\fs18 27 	\}	
\fs20 \

\fs18 28 	x->f_position = x->f_sequence_length - 1;
\fs20 \

\fs18 29 	x->d_position = x->d_sequence_length - 1;
\fs20 \

\fs18 30 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.28
\f0\b0  The revised list method incorporating a duration sequence\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs18 \cf0  1 void retroseq_tempo(t_retroseq *x, t_symbol *msg, short argc, 
\fs20 \
\pard\pardeftab720\fi720\ri0\ql\qnatural

\fs18 \cf0 t_atom *argv)
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  2 \{
\fs20 \

\fs18  3 	float old_tempo;
\fs20 \

\fs18  4 	float t;
\fs20 \

\fs18  5 	if(argc == 1)\{
\fs20 \

\fs18  6 		t = atom_getfloatarg(0, argc,argv);
\fs20 \

\fs18  7 	\} 
\fs20 \

\fs18  8 	else \{
\fs20 \

\fs18  9 		return;
\fs20 \

\fs18 10 	\}
\fs20 \

\fs18 11 	if( t <= 0 )\{
\fs20 \

\fs18 12 		error("retroseq~: tempo must be greater than zero");
\fs20 \

\fs18 13 		return;
\fs20 \

\fs18 14 	\}
\fs20 \

\fs18 15 	old_tempo = x->tempo;
\fs20 \

\fs18 16 	x->tempo = t;
\fs20 \

\fs18 17 	x->duration_factor = (60.0/x->tempo)*(x->sr/1000.0);
\fs20 \

\fs18 18 	x->counter *= old_tempo / x->tempo; 
\fs20 \

\fs18 19 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 6.29
\f0\b0  Making tempo changes instantaneous in the tempo method\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_dsp(t_retroseq *x, t_signal **sp, short *count)\
 2 \{\
 3 	if( x->sr != sp[0]->s_sr )\{\
 4 		if( ! sp[0]->s_sr )\{\
 5 			error("zero sampling rate!");\
 6 			return;\
 7 		\}\
 8 		x->counter *= x->sr/sp[0]->s_sr; // rescale countdown\
 9 		x->duration_factor *=  sp[0]->s_sr/x->sr; // rescale factor\
10 		x->sr = sp[0]->s_sr; // assign new sampling rate\
11 	\}\
12 	dsp_add(retroseq_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);\
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.30
\f0\b0  Making tempo changes instantaneous in the dsp method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 t_int *retroseq_perform(t_int *w)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *) (w[1]);\
 4 	float *out = (t_float *)(w[2]);\
 5 	int n = w[3];\
 6 	int f_sequence_length = x->f_sequence_length;\
 7 	int d_sequence_length = x->d_sequence_length;\
 8 	int counter = x->counter;\
 9 	int f_position = x->f_position;\
10 	int d_position = x->d_position;\
11 	float *f_sequence = x->f_sequence;\
12 	float *d_sequence = x->d_sequence;\
13 	float current_value = x->current_value;\
14 	float duration_factor = x->duration_factor;\
15 	\
16 	while(n--)\{\
17 		if(! counter--)\{\
18 			if(++f_position >= f_sequence_length)\{\
19 				f_position = 0;\
20 			\}\
21 			if(++d_position >= d_sequence_length)\{\
22 				d_position = 0;\
23 			\}\
24 			counter = d_sequence[d_position] * duration_factor;\
25 			current_value = f_sequence[f_position];\
26 			\
27 		\}\
28 		*out++ = current_value;\
29 	\}\
30 	x->current_value = current_value;\
31 	x->counter = counter;\
32 	x->f_position = f_position;\
33 	x->d_position = d_position;	\
34 	return w + 4;\
35 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.31
\f0\b0  The revised perform method\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_free(t_retroseq *x)\
2 \{\
3 	dsp_free((t_pxobject *)x);\
4 	sysmem_freeptr(x->d_sequence);\
5 	sysmem_freeptr(x->f_sequence);\
6 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.32
\f0\b0  Updating the free function\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void retroseq_freqlist(t_retroseq *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	int i;\
 4 	float *f_sequence = x->f_sequence;\
 5 	if( argc < 2 )\{\
 6 		return;\
 7 	\}\
 8 	x->f_sequence_length = argc;\
 9 	if( x->f_sequence_length  >= MAX_SEQUENCE )\{\
10 		error("retroseq~: frequency sequence is too long");\
11 		return;\
12 	\} \
13 	for (i=0 ; i < argc; i++) \{\
14 		f_sequence[i] = atom_getfloatarg(i,argc,argv);\
15 	\}\
16 	x->f_position = x->f_sequence_length - 1;\
17 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.33
\f0\b0  The data entry method for the frequency sequence\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 class_addmethod(c,(method)retroseq_durlist,"durlist", A_GIMME,0);\
2 class_addmethod(c,(method)retroseq_freqlist,"freqlist", A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.34
\f0\b0  Binding the data entry methods for the duration and frequency sequences\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *list_outlet; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.36
\f0\b0  The list outlet component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 x->list_outlet = listout((t_pxobject *)x);\
2 dsp_setup((t_pxobject *)x,1);\
3 outlet_new((t_pxobject *)x, "signal");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.37
\f0\b0  Initializing the outlets in the new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *the_clock; // clock for non-signal events\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.38
\f0\b0  The clock component of the object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->the_clock = clock_new(x,(method)retroseq_send_adsr);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.39
\f0\b0  Initializing the clock in the new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 t_atom *adsr_list; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.43
\f0\b0  The ADSR list component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->adsr_list = (t_atom *) sysmem_getptr(10 * sizeof(t_atom));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.44
\f0\b0  Allocating memory for the ADSR list\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float *adsr; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.45
\f0\b0  The ADSR data component for the object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float sustain_amplitude; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.46
\f0\b0  The sustain amplitude level component\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page x->adsr = (float *) sysmem_newptr (4 * sizeof(float));
\f0\fs24 \

\f1\fs20 \
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.47
\f0\b0  Allocating memory for the ADSR data\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->sustain_amplitude = 0.7; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.48
\f0\b0  Initializing the amplitude sustain level\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float *adsr_out;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.49
\f0\b0  The ADSR output data component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->adsr_out = (float *) sysmem_newptr(10 * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.50
\f0\b0  Allocating memory for the ADSR output data\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->adsr_out[0] = 0.0;\
2 x->adsr_out[1] = 0.0;\
3 x->adsr_out[2] = 1.0;\
4 x->adsr_out[8] = 0.0;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.51
\f0\b0  Initializing the fixed amplitude data points\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->adsr[0] = 20;\
2 x->adsr[1] = 50;\
3 x->adsr[2] = 100;\
4 x->adsr[3] = 50;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.52
\f0\b0  Initializing duration values of the ADSR\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_send_adsr(t_retroseq *x)\
 2 \{\
 3   t_atom *adsr_list = x->adsr_list;\
 4   float *adsr = x->adsr;\
 5   float *adsr_out = x->adsr_out;\
 6   float note_duration_ms = x->note_duration_ms;\
 7   int i;\
 8 \
 9   /* envelope data massaging omitted for now */\
10 \
11   for( i = 0; i < 10; i++ )\{\
12     SETFLOAT(adsr_list+i,adsr_out[i]);\
13   \}\
14   outlet_list(x->list_outlet,NULL,10,adsr_list);\
15 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.53
\f0\b0  Sending the ADSR data to the list outlet\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *outlet_list(void *o, t_symbol *s, short ac, t_atom *av);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.54
\f0\b0  The function prototype for 
\f1\fs20 outlet_list()\
\
\
\
#define SETFLOAT(ap, x) ((ap)->a_type = A_FLOAT,(ap)->a_w.w_float = \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 (x))\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.55
\f0\b0  The Max/MSP 
\f1\fs20 SETFLOAT()
\f0\fs24  macro (courtesy of Cycling \'9274)\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 int x;\
2 int *px; \
3 \
4 x = 5;\
5 px = &x; \
6 \
7 /* pointer px now contains the address of x, so *px is equal to 5 */\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.56
\f0\b0  Assigning a pointer address\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 int x[4];\
2 int *px;\
3 \
4 x[2] = 5;\
5 px = &x[2];\
6 \
7 /* now *px is 5 again */\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.57
\f0\b0  Assigning an address within an array to a pointer\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for(i = 0; i < 10; i++)\{\
2 SETFLOAT(adsr_list+i,adsr_out[i]);\
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.58
\f0\b0  Using the 
\f1\fs20 SETFLOAT()
\f0\fs24  macro\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 short elastic_sustain; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.59
\f0\b0  The flag for envelope time-scaling\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->elastic_sustain = 0;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.60
\f0\b0  Initializing the envelope time-scaling flag\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \
\page  1 void retroseq_send_adsr(t_retroseq *x)\
 2 \{\
 3   t_atom *adsr_list = x->adsr_list;\
 4   float *adsr = x->adsr;\
 5   float *adsr_out = x->adsr_out;\
 6   float note_duration_ms;\
 7   float duration_sum;\
 8   short elastic_sustain = x->elastic_sustain;\
 9   int d_position = x->d_position;\
10   float *d_sequence = x->d_sequence;\
11   float tempo = x->tempo;\
12   float rescale ;\
13   int i;\
14 \
15   note_duration_ms = d_sequence[d_position] * (60.0/tempo);\
16   adsr_out[4] = adsr_out[6] = x->sustain_amplitude;\
17   adsr_out[3] = adsr[0]; // attack duration\
18   adsr_out[5] = adsr[1]; // decay duration\
19   adsr_out[9] = adsr[3]; // release duration\
20   if(elastic_sustain)\{\
21     adsr_out[7] = note_duration_ms - (adsr[0]+adsr[1]+adsr[3]);\
22     if(adsr_out[7] < 1.0) // minimum sustain of 1 millisecond\
23       adsr_out[7] = 1.0 ;\
24   \} else \{\
25     adsr_out[7] = adsr[2]; // user specified sustain duration\
26   \}\
27   duration_sum = adsr_out[3] + adsr_out[5] + adsr_out[7] + \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 adsr_out[9];\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 28   if(duration_sum > note_duration_ms)\{\
29     rescale = note_duration_ms / duration_sum ;\
30     adsr_out[3] *= rescale ;\
31     adsr_out[5] *= rescale ;\
32     adsr_out[7] *= rescale ;\
33     adsr_out[9] *= rescale ;\
34   \}\
35   for(i = 0; i < 10; i++)\{\
36     SETFLOAT(adsr_list+i,adsr_out[i]);\
37   \}\
38   outlet_list(x->list_outlet,NULL,10,adsr_list); \
39 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.61
\f0\b0  The 
\f1\fs20 retroseq_send_adsr()
\f0\fs24  method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 while(n--)\{\
 2 	if(! counter--)\{\
 3 		if(++f_position >= f_sequence_length)\{\
 4 			f_position = 0;\
 5 		\}\
 6 		if(++d_position >= d_sequence_length)\{\
 7 			d_position = 0;\
 8 		\}\
 9 		counter = d_sequence[d_position] * duration_factor;\
10 		current_value = f_sequence[f_position];\
11 		clock_delay(x->the_clock,0); // defer list output\
12 	\}\
13 	*out++ = current_value;\
14 \}	\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.62
\f4\b0  Sending the ADSR data to an outlet from the DSP loop with 
\f1\fs20 clock_delay()\
\
\
\
 1 void retroseq_adsr(t_retroseq *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	float *adsr = x->adsr;\
 4 	int i;\
 5 	\
 6 	if( argc < 4 )\{\
 7 		error("not enough parameters for adsr (should be 4)");\
 8 		return;\
 9 	\}\
10 	for (i=0 ; i < 4; i++) \{\
11 		adsr[i] = atom_getfloatarg(i,argc,argv);\
12 		if( adsr[i] < 1.0 )\{\
13 			adsr[i] = 1.0;\
14 		\}\
15 	\}\
16 \}\
\
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 6.63
\f4\b0  The input method for ADSR data\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_sustain_amplitude(t_retroseq *x, t_symbol *msg, short argc, t_atom *argv)\
2 \{\
3 	if(argc >= 1)\{\
4 		x->sustain_amplitude = atom_getfloatarg(0,argc,argv);\
5 	\}\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.64
\f4\b0  Setting the sustain amplitude\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 void retroseq_elastic_sustain(t_retroseq *x, t_symbol *msg, short argc, t_atom *argv)\
2 \{\
3 	if(argc >= 1)\{\
4 		x->elastic_sustain = (short) atom_getfloatarg(0,argc,argv);\
5 	\}\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.65
\f4\b0  Setting the sustain duration\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 class_addmethod(c, (method)retroseq_adsr, "adsr", A_GIMME, 0);\
2 class_addmethod(c, (method)retroseq_sustain_amplitude,"sustain_amplitude", A_GIMME, 0);\
3 class_addmethod(c, (method)retroseq_elastic_sustain,"elastic_sustain", A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.66
\f0\b0  Binding the new ADSR-related methods\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void retroseq_free(t_retroseq *x)\
 2 \{\
 3 	dsp_free((t_pxobject *)x);\
 4 	sysmem_freeptr(x->d_sequence);\
 5 	sysmem_freeptr(x->f_sequence);\
 6 	sysmem_freeptr(x->adsr);\
 7 	sysmem_freeptr(x->adsr_out);\
 8 	sysmem_freeptr(x->adsr_list);\
 9 	object_free(x->the_clock);\
10 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.67
\f4\b0  The revised 
\f1\fs20 retroseq_free()
\f4\fs24  function\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *bang_outlet; // start-of-sequence bang outlet\
void *bang_clock; // clock for the bang\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.69
\f0\b0  New components to send a bang from 
\i retroseq~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 x->bang_outlet = bangout((t_pxobject *)x);\
2 x->list_outlet = listout((t_pxobject *)x);\
3 dsp_setup((t_pxobject *)x,0);\
4 outlet_new((t_pxobject *)x, "signal"); \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.70
\f0\b0  Instantiating the outlets in the new instance routine\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_send_bang(t_retroseq *x) \
2 \{\
3   outlet_bang(x->bang_outlet);\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.71
\f0\b0  The 
\f1\fs20 retroseq_send_bang()
\f0\fs24  routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->bang_clock = clock_new(x,(method)retroseq_send_bang);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.72
\f0\b0  Binding the outlet bang routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 while(n--)\{\
 2   if(! counter--)\{\
 3     if(++f_position >= f_sequence_length)\{\
 4       f_position = 0;\
 5       clock_delay(x->bang_clock,0); // send a bang\
 6     \}\
 7     if(++d_position >= d_sequence_length)\
 8       d_position = 0;\
 9     counter = d_sequence[d_position] * duration_factor ;\
10     current_value = f_sequence[f_position];\
11     clock_delay(x->the_clock,0); // defer list output\
12   \}\
13   *out++ = current_value;\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.73
\f0\b0  The perform loop revised to send a bang\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 object_free(x->list_clock);\
2 object_free(x->bang_clock);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.74
\f0\b0  Freeing the clocks when the object is destroyed\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_assist (t_retroseq *x, void *b, long msg, long arg, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 char *dst)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	if (msg == ASSIST_INLET) \{\
 4 		sprintf(dst,"(messages) ");\
 5 \
 6 	\} else if (msg == ASSIST_OUTLET) \{\
 7 		switch (arg)\{\
 8 			case 0:\
 9 				sprintf(dst,"(signal) Output");\
10 				break;\
11 			case 1:\
12 				sprintf(dst,"(list) ADSR envelope");\
13 				break;\
14 			case 2:\
15 				sprintf(dst,"(bang) Sequence Start Bang");\
16 				break;\
17 		\}\
18 	\}\
19 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.75
\f4\b0  The assist method for 
\i retroseq~
\i0 \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 srand(clock()); \
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.78
\f0\b0  Seeding the random number generator\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 int rpos;\
2 float rand_member;\
3 \
4 rpos = rand() % len;\
5 rand_member = seq[rpos];\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.79
\f0\b0  Extracting a random member of a sequence\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \
\page  1 void retroseq_permute(float *sequence, float *permutation, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 int len)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3   int cnt = 0;\
 4   int rpos;\
 5   float tmp;\
 6   int i;\
 7   int tlen = len;\
 8 \
 9   while(tlen > 1)\{\
10     rpos = rand() % tlen ;\
11     permutation[cnt++] = sequence[rpos];\
12     tmp = sequence[rpos]; // swap here\
13     sequence[rpos] = sequence[tlen - 1];\
14     sequence[tlen - 1] = tmp;\
15     --tlen;\
16   \}\
17   permutation[len - 1] = sequence[0];\
18   for( i = 0; i < len; i++ )\{\
19     sequence[i] = permutation[i];\
20   \}\
21 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.80
\f0\b0  The 
\f1\fs20 retroseq_permute()
\f0\fs24  method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float *tmp_permutation; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.81
\f0\b0  A temporary work space component for the object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->tmp_permutation = (float *)sysmem_newptr(MAX_SEQUENCE * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.82
\f0\b0  Allocating memory for the permutation work space\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 sysmem_freeptr(x->tmp_permutation);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.83
\f0\b0  Freeing memory\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page 1 void retroseq_shuffle_freqs(t_retroseq *x)\
2 \{\
3   float *tmp_permutation = x->tmp_permutation;\
4   float *f_sequence = x->f_sequence;\
5   int f_sequence_length = x->f_sequence_length;\
6   retroseq_permute(f_sequence, tmp_permutation, f_sequence_length);\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.84
\f0\b0  The 
\f1\fs20 retroseq_shuffle_freqs()
\f0\fs24  method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_shuffle_durs(t_retroseq *x)\
2 \{\
3   float *tmp_permutation = x->tmp_permutation;\
4   float *d_sequence = x->d_sequence;\
5   int d_sequence_length = x->d_sequence_length;\
6   retroseq_permute(d_sequence, tmp_permutation, d_sequence_length);\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.85
\f0\b0  the 
\f1\fs20 retroseq_shuffle_durs()
\f0  
\fs24 method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_shuffle(t_retroseq *x)\
2 \{\
3   retroseq_shuffle_freqs(x);\
4   retroseq_shuffle_durs(x);\
5 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.86
\f0\b0  Combining both shuffle methods into a single method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 class_addmethod(c, (method)retroseq_shuffle_freqs, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 "shuffle_freqs",0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 2 class_addmethod(c, (method)retroseq_shuffle_durs, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 "shuffle_durs",0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 3 class_addmethod(c, (method)retroseq_shuffle, "shuffle",0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.87
\f0\b0  Binding the shuffle methods\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 void *f_plist_outlet; // outlet for permuted frequencies\
void *d_plist_outlet; // outlet for permuted durations\
t_atom *pseq_list; // holds permuted lists\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.88
\f0\b0  Object components for new list outlets\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->pseq_list = (t_atom *) sysmem_newptr(MAX_SEQUENCE * \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 sizeof(t_atom));\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.89
\f0\b0  Allocating memory for the atom list\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 sysmem_freeptr(x->pseq_list);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.90
\f0\b0  Freeing memory for the atom list\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->d_plist_outlet = listout((t_pxobject *)x);\
2 x->f_plist_outlet = listout((t_pxobject *)x);\
3 x->bang_outlet = bangout((t_pxobject *)x);\
4 x->list_outlet = listout((t_pxobject *)x);\
5 dsp_setup((t_pxobject *)x,0);\
6 outlet_new((t_pxobject *)x, "signal");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.91
\f0\b0  Revised outlet instantiation calls in the new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void retroseq_shuffle_freqs(t_retroseq *x)\
 2 \{\
 3   float *tmp_permutation = x->tmp_permutation;\
 4   float *f_sequence = x->f_sequence;\
 5   int f_sequence_length = x->f_sequence_length;\
 6   t_atom *pseq_list = x->pseq_list;\
 7   int i;\
 8 \
 9   retroseq_permute(f_sequence, tmp_permutation, f_sequence_length);\
10   for( i = 0; i < f_sequence_length; i++ )\{\
11 		SETFLOAT(pseq_list+i,f_sequence[i]);\
12   \}\
13   outlet_list(x->f_plist_outlet,NULL,f_sequence_length,pseq_list);\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.92
\f0\b0  The updated frequency sequence shuffle method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_shuffle_durs(t_retroseq *x)\
 2 \{\
 3   float *tmp_permutation = x->tmp_permutation;\
 4   float *d_sequence = x->d_sequence;\
 5   int d_sequence_length = x->d_sequence_length;\
 6   t_atom *pseq_list = x->pseq_list;\
 7   int i;\
 8 \
 9   retroseq_permute(d_sequence, tmp_permutation, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 d_sequence_length);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 10   for( i = 0; i < d_sequence_length; i++ )\{\
11     SETFLOAT(pseq_list+i,d_sequence[i]);\
12   \}\
13   outlet_list(x->d_plist_outlet,NULL,d_sequence_length,pseq_list);\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.93
\f0\b0  The updated duration sequence shuffle method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void retroseq_assist (t_retroseq *x, void *b, long msg, long arg, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 char *dst)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	if (msg == ASSIST_INLET) \{\
 4 		sprintf(dst,"(messages) ");\
 5 \
 6 	\} else if (msg == ASSIST_OUTLET) \{\
 7 		switch (arg)\{\
 8 			case 0:\
 9 				sprintf(dst,"(signal) Output");\
10 				break;\
11 			case 1:\
12 				sprintf(dst,"(list) ADSR envelope");\
13 				break;\
14 			case 2:\
15 				sprintf(dst,"(bang) Sequence Start Bang");\
16 				break;\
17 			case 3:\
18 				sprintf(dst,"(list) Permuted Frequency List");\
19 				break;\
20 			case 4:\
21 				sprintf(dst,"(list) Permuted Duration List");\
22 				break;				\
23 		\}\
24 	\}\
25 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.94
\f0\b0  The updated assist method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page short manual_override; // toggle manual override\
short trigger_sent; // user sent a bang\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.96
\f0\b0  Object structure components for manual override\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs18 \cf0  
\fs20 \

\fs18 \page  
\fs20 1 t_int *retroseq_perform(t_int *w)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *) (w[1]);\
 4 	float *out = (t_float *)(w[2]);\
 5 	int n = w[3];\
 6 	int f_sequence_length = x->f_sequence_length;\
 7 	int d_sequence_length = x->d_sequence_length;\
 8 	int counter = x->counter;\
 9 	int f_position = x->f_position;\
10 	int d_position = x->d_position;\
11 	float *f_sequence = x->f_sequence;\
12 	float *d_sequence = x->d_sequence;\
13 	float current_value = x->current_value;\
14 	float duration_factor = x->duration_factor;\
15 	short manual_override = x->manual_override;\
16 	short trigger_sent = x->trigger_sent;\
17 	\
18 	if( manual_override )\{\
19 		while(n--)\{\
20 			if( trigger_sent )\{\
21 				trigger_sent = 0;\
22 				++f_position;\
23 				if( f_position >= f_sequence_length )\{\
24 					f_position = 0;\
25 					clock_delay(x->bang_clock,0);\
26 				\}\
27 				current_value = f_sequence[f_position];\
28 				clock_delay(x->list_clock,0);\
29 			\}\
30 			*out++ = current_value;\
31 		\}\
32 	\} \
33 	else \{\
34 		while(n--)\{\
35 			if(! counter--)\{\
36 				if(++f_position >= f_sequence_length)\{\
37 					f_position = 0;\
38 					clock_delay(x->bang_clock,0); \
39 				\}\
40 				if(++d_position >= d_sequence_length)\{\
41 					d_position = 0;\
42 				\}\
43 				counter = d_sequence[d_position] * \
\pard\pardeftab720\li2880\fi720\ri0\ql\qnatural
\cf0 duration_factor ;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 44 				current_value = f_sequence[f_position];\
45 				clock_delay(x->list_clock,0); \
46 			\}\
47 			*out++ = current_value;\
48 		\}\
49 	\}\
50 	x->trigger_sent = trigger_sent;\
51 	x->current_value = current_value;\
52 	x->counter = counter;\
53 	x->f_position = f_position;\
54 	x->d_position = d_position;	\
55 	return w + 4;\
56 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.97
\f0\b0  The revised perform routine with manual override logic\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_manual_override(t_retroseq *x, long state)\
2 \{\
3   x->manual_override = (short) state;\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.98
\f0\b0  The manual override method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void retroseq_bang(t_retroseq *x)\
2 \{\
3   x->trigger_sent = 1;\
4 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.99
\f0\b0  Using the Max 
\i bang
\i0  message to send a manual trigger\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 class_addmethod(c, (method)retroseq_bang, "bang",0);\
2 class_addmethod(c, (method)retroseq_manual_override, \
 	"manual_override", A_LONG, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.100
\f0\b0  Binding the \'93bang\'94 and \'93manual_override\'94 methods\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 if(x->manual_override)\{\
 2   adsr_out[7] = adsr[2]; // swap in user sustain\
 3 \} \
 4 else \{\
 5   if(elastic_sustain)\{\
 6     adsr_out[7] = note_duration_ms - (adsr[0]+adsr[1]+adsr[3]);\
 7     if(adsr_out[7] < 1.0) // minimum sustain of 1 millisecond\
 8       adsr_out[7] = 1.0 ;\
 9   \} else \{\
10     adsr_out[7] = adsr[2]; // user specified sustain duration\
11   \}\
12   duration_sum = adsr_out[3] + adsr_out[5] + adsr_out[7] + adsr_out[9];\
13 \
14   /* if note is shorter than total then rescale envelope */\
15 \
16   if(duration_sum > note_duration_ms)\{\
17     rescale = note_duration_ms / duration_sum ;\
18     adsr_out[3] *= rescale;\
19     adsr_out[5] *= rescale;\
20     adsr_out[7] *= rescale;\
21     adsr_out[9] *= rescale;\
22   \}\
23 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.102
\f0\b0  Modifications to
\fs20  
\f1 retroseq_send_adsr()\
\page  1 void retroseq_tilde_setup(void)\
 2 \{\
 3 	t_class *c;\
 4 	retroseq_class = class_new(gensym("retroseq~"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (t_newmethod)retroseq_new, \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  		(t_method)retroseq_free, sizeof(t_retroseq), \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 0,A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  5 	c = retroseq_class;\
 6 	class_addmethod(c, (t_method)retroseq_dsp, gensym("dsp"),0, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_CANT, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  7 	class_addmethod(c, (t_method)retroseq_list, gensym("list"),\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  8 	class_addmethod(c, (t_method)retroseq_durlist, \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 gensym("durlist"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  9 	class_addmethod(c, (t_method)retroseq_freqlist, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("freqlist"), A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 10 	class_addmethod(c, (t_method)retroseq_tempo, gensym("tempo"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	class_addmethod(c, (t_method)retroseq_adsr, gensym("adsr"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 12 	class_addmethod(c, (t_method)retroseq_sustain_amplitude, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("sustain_amplitude"), A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 13 	class_addmethod(c, (t_method)retroseq_elastic_sustain,gensym( \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 "elastic_sustain"), A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 14 	class_addmethod(c, (t_method)retroseq_shuffle_freqs, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("shuffle_freqs"),0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 15 	class_addmethod(c, (t_method)retroseq_shuffle_durs, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("shuffle_durs"),0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 16 	class_addmethod(c, (t_method)retroseq_shuffle, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("shuffle"),0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 	class_addmethod(c, (t_method)retroseq_manual_override, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("manual_override"), A_GIMME, 0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 18 	class_addmethod(c, (t_method)retroseq_bang, gensym("bang"),0);\
19 	post("retroseq~ from \\\'94Designing Audio Objects\\\'94 by Eric Lyon");\
20 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.104
\f4\b0  The initialization routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void retroseq_free(t_retroseq *x)\
 2 \{\
 3 	freebytes(x->d_sequence, MAX_SEQUENCE*sizeof(float));\
 4 	freebytes(x->f_sequence, MAX_SEQUENCE*sizeof(float));\
 5 	freebytes(x->adsr, 4 * sizeof(float));\
 6 	freebytes(x->adsr_out, 10 * sizeof(float));\
 7 	freebytes(x->adsr_list, 10 * sizeof(t_atom));\
 8 	freebytes(x->tmp_permutation, MAX_SEQUENCE * sizeof(float));\
 9 	freebytes(x->pseq_list, MAX_SEQUENCE * sizeof(t_atom));\
10 	clock_free(x->list_clock);\
11 	clock_free(x->bang_clock);\
12 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.105
\f0\b0  Using Pd function calls in the 
\f1\fs20 retroseq_free()
\f0\fs24  routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void *retroseq_new(t_symbol *s, short argc, t_atom *argv)\
 2 \{\
 3 	t_retroseq *x = (t_retroseq *)pd_new(retroseq_class);\
 4    outlet_new(&x->obj, gensym("signal"));\
 5    x->list_outlet = outlet_new(&x->obj, gensym("list"));\
 6    x->bang_outlet = outlet_new(&x->obj, gensym("bang"));\
 7    x->f_plist_outlet = outlet_new(&x->obj, gensym("list"));\
 8 	x->d_plist_outlet = outlet_new(&x->obj, gensym("list"));\
 9 	x->sr =  sys_getsr();\
10 	if(!x->sr)\{\
11 		x->sr = 44100.0; \
12 	\}\
13 	x->list_clock = clock_new(x,(t_method)retroseq_send_adsr);\
14 	x->bang_clock = clock_new(x,(t_method)retroseq_send_bang);\
15 	x->f_sequence = (float *)getbytes(MAX_SEQUENCE*sizeof(float));\
16 	x->d_sequence = (float *)getbytes(MAX_SEQUENCE*sizeof(float) );\
17 	x->adsr_list = (t_atom *) getbytes(10 * sizeof(t_atom));\
18 	x->adsr_out = (float *) getbytes(10 * sizeof(float));\
19 	x->adsr = (float *) getbytes(4 * sizeof(float));\
20 	x->tmp_permutation = (float *)getbytes(MAX_SEQUENCE * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 21 	x->pseq_list = (t_atom *) getbytes(MAX_SEQUENCE * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sizeof(t_atom));	\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 22 	if(x->f_sequence == NULL || x->d_sequence == NULL)\{\
23 		post("retroseq~: memory allocation fail");\
24 		return NULL;\
25 	\}\
26 	srand(clock()); \
27 	x->f_position = 0;\
28 	x->d_position = 0;\
29 	x->elastic_sustain = 0;\
30 	x->tempo = 60.0;\
31 	x->duration_factor = x->sr/1000.0;\
32 	x->f_sequence_length = 3;\
33 	x->d_sequence_length = 3;\
34 	x->f_sequence[0] = 440;\
35 	x->f_sequence[1] = 550;\
36 	x->f_sequence[2] = 660;\
37 	x->d_sequence[0] = 250;\
38 	x->d_sequence[1] = 125;\
39 	x->d_sequence[2] = 125;\
40 	x->adsr_out[0] = 0.0;\
41 	x->adsr_out[1] = 0.0;\
42 	x->adsr_out[2] = 1.0;\
43 	x->adsr_out[8] = 0.0;\
44 	x->adsr[0] = 20;\
45 	x->adsr[1] = 50;\
46 	x->adsr[2] = 100;\
47 	x->adsr[3] = 50;\
48 	x->sustain_amplitude = 0.7;\
49 	x->current_value = x->f_sequence[0];\
50 	x->counter = x->d_sequence[0] * x->sr/ 1000.0 ;	\
51 	return x;\
52 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 6.106
\f0\b0  The revised new instance routing for the Pd version of 
\i retroseq~
\i0 \
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #include "ext.h"							\
#include "ext_obex.h"						\
#include "buffer.h" \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.1
\f0\b0  Required header files for Max/MSP buffer operations\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _bed \
\{\
	t_object	obj;\
	t_symbol	*b_name;\
	t_buffer	*buffy;\
\} t_bed;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.2
\f0\b0  The 
\i bed
\i0  object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct symbol\
\{\
	char *s_name;			///< name: a c-string\
	struct object *s_thing;	///< possible binding to a t_object\
\} Symbol, t_symbol;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.3
\f0\b0  The Max/MSP symbol structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 int attach_buffer(t_bed *x)\
 2 \{\
 3 	t_object *o;\
 4 	o = x->b_name->s_thing;\
 5 	if(o == NULL)\{\
\pard\pardeftab720\li1440\fi-1440\ri0\sb2\sa2\ql\qnatural
\cf0  6 	object_post((t_object *)x,
\f7 \uc0\u8232 
\f1     "\\"%s\\" is not a valid buffer", x->b_name->s_name); \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  7 		return 0;\
 8 	\}\
 9 	if (ob_sym(o) == gensym("buffer~")) \{\
10 		x->buffy = (t_buffer *) o;\
11 		return 1;\
12 	\} else \{\
13 		return 0;\
14 	\}\
15 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.4
\f0\b0  Using a buffer symbol to gain access to the corresponding buffer object\
\
\
\page   
\f1\fs20 1 void bed_info(t_bed *x)\
 2 \{\
 3 	t_buffer *b;\
 4 	if( ! attach_buffer(x) )\{\
 5 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
 6 		return;\
 7 	\} 	\
 8 	b = x->buffy;\
 9 	post("my name is: %s", b->b_name->s_name);\
10 	post("my frame count is: %d", b->b_frames);\
11 	post("my channel count is: %d", b->b_nchans);\
12 	post("my validity is: %d", b->b_valid);\
13 	post("my in use status is: %d", b->b_inuse);\
14 \}\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.5
\f0\b0  Printing out buffer information\
\
\
\
\pard\pardeftab720\ri0\sb2\sa2\ql\qnatural

\f1\fs20 \cf0 1 void bed_bufname(t_bed *x, t_symbol *name) \
2 \{
\f7 \uc0\u8232 
\f1 3     x->b_name = name;
\f7 \uc0\u8232 
\f1 4 \} \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.6
\f0\b0  The bufname method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void *bed_new(t_symbol *s, short argc, t_atom *argv)\
2 \{\
3 	t_bed *x = (t_bed *)object_alloc(bed_class); \
4 	atom_arg_getsym(&x->b_name, 0, argc, argv);\
5 	return x;\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.7
\f0\b0  The new instance routine for 
\i bed\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  \
\page  1 void bed_normalize(t_bed *x)\
 2 \{\
 3 	t_buffer *b;\
 4 	float maxamp = 0.0;\
 5 	float rescale;\
 6 	int i;\
 7 	\
 8 	if(! attach_buffer(x))\{\
 9 		object_post((t_object *)x, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 "normalize: %s is not a valid buffer",x->b_name->s_name);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 10 		return;\
11 	\}	\
12 	b = x->buffy;\
13 	for(i = 0; i < b->b_frames * b->b_nchans; i++)\{\
14 		if(maxamp < fabs(b->b_samples[i]) )\{\
15 			maxamp = fabs(b->b_samples[i]);\
16 		\}\
17 	\}\
18 	if(maxamp > 0.0000001)\{\
19 		rescale = 1.0 / maxamp;\
20 	\} \
21 	else \{\
22 	post("rescale: amplitude is too low to rescale: %f", maxamp);\
23 		return;\
24 	\}\
25 	for(i = 0; i < b->b_frames * b->b_nchans; i++)\{\
26 		b->b_samples[i] *= rescale;\
27 	\}	\
28 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.9
\f0\b0  The normalization method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void bed_normalize(t_bed *x)\
 2 \{\
 3 	t_buffer *b;\
 4 	float maxamp = 0.0;\
 5 	float rescale;\
 6 	int i;\
 7 	\
 8 	if( ! attach_buffer(x) )\{\
 9 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
10 		return;\
11 	\} \
12 	b = x->buffy;\
13 	ATOMIC_INCREMENT(&b->b_inuse);\
14 	if (!b->b_valid) \{\
15 		ATOMIC_DECREMENT(&b->b_inuse);\
16 		object_post((t_object *)x,\
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 "bed normalize: not a valid buffer!");\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 		return;\
18 	\}\
19 	for(i = 0; i < b->b_frames * b->b_nchans; i++)\{\
20 		if(maxamp < fabs(b->b_samples[i]) )\{\
21 			maxamp = fabs(b->b_samples[i]);\
22 		\}\
23 	\}\
24 	if(maxamp > 0.000001)\{\
25 		rescale = 1.0 / maxamp;\
26 	\} \
27 	else \{\
28 		object_post((t_object *)x,\
\pard\pardeftab720\li1440\ri0\ql\qnatural
\cf0 "rescale: amplitude is too low to rescale: %f",maxamp);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 29 		ATOMIC_DECREMENT(&b->b_inuse);\
30 		return;\
31 	\}\
32 	for(i = 0; i < b->b_frames * b->b_nchans; i++)\{\
33 		b->b_samples[i] *= rescale;\
34 	\}	\
35 	object_method((t_object *)b, gensym("dirty"));\
36 	ATOMIC_DECREMENT(&b->b_inuse);\
37 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.11
\f0\b0  Thread-safe buffer access\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 float	*undo_samples; // contains samples to undo previous operation\
long	undo_start; // start frame for the undo replace\
long	undo_frames; // how many frames in the undo\
long	can_undo; // flag that an undo is possible\
long	undo_resize; // flag that the undo process will resize buffer\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.12
\f0\b0  New components to support an undo method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void bed_normalize(t_bed *x)\
 2 \{\
 3 // code omitted here	\
 4 	// store samples for undo\
 5 	chunksize = b->b_frames * b->b_nchans * sizeof(float);\
 6 	if( x->undo_samples == NULL )\{\
 7 		x->undo_samples = (float *) sysmem_newptr(chunksize);\
 8 	\} else \{\
 9 		x->undo_samples = \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 (float *) sysmem_resizeptr(x->undo_samples, chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 10 	\}\
11 	if(x->undo_samples == NULL)\{\
12 		post("bed: cannot allocate memory for undo");\
13 		x->can_undo = 0;\
14 		ATOMIC_DECREMENT(&b->b_inuse);\
15 		return;\
16 	\} else \{\
17 		x->can_undo = 1;\
18 		x->undo_start = 0;\
19 		x->undo_frames = b->b_frames;\
20 		x->undo_resize = 0;\
21 		sysmem_cpyptr(b->b_samples, x->undo_samples, chunksize);\
22 	\}\
23 // code omitted here	\
24 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.13
\f0\b0  Preparing the normalization method for an undo action\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 for( i  = 0; i < b->b_frames * b->b_nchans; i++)\{\
2 	b->undo_samples[i] = b->b_samples[i];\
3 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.14
\f0\b0  Copying a memory block, one sample at a time\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void bed_undo(t_bed *x)\
 2 \{\
 3 	t_buffer *b;\
 4 	long chunksize; // size of memory alloc in bytes\
 5 	t_atom rv; // needed for message call\
 6 	\
 7 	if(! x->can_undo )\{\
 8 		post("bed: nothing to undo");\
 9 		return;\
10 	\}	\
11 	if( ! attach_buffer(x) )\{\
12 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
13 		return;\
14 	\} \
15 	b = x->buffy;\
16 	ATOMIC_INCREMENT(&b->b_inuse);\
17     if (!b->b_valid) \{\
18 		ATOMIC_DECREMENT(&b->b_inuse);\
19 		post("bed undo: not a valid buffer!");\
20     	return;\
21 	\}\
22 	chunksize = x->undo_frames * b->b_nchans * sizeof(float);\
23 	if(x->undo_resize)\{\
24 		ATOMIC_DECREMENT(&b->b_inuse);\
25 		object_method_long(&b->b_obj, gensym("sizeinsamps"), \
		x->undo_frames, &rv);\
26 		ATOMIC_INCREMENT(&b->b_inuse);\
27 	\}\
28 	sysmem_copyptr(x->undo_samples,  \
		b->b_samples + x->undo_start, chunksize);\
29 	x->can_undo = 0;\
30 	object_method((t_object *)b, gensym("dirty"));\
31 	ATOMIC_DECREMENT(&b->b_inuse);	\
32 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.17
\f0\b0  The undo method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void bed_fadein(t_bed *x, double fadetime)\
 2 \{\
 3 	t_buffer *b;\
 4 	long chunksize; // size of memory alloc in bytes\
 5 	long fadeframes; // frames to fade for\
 6 	int i,j;\
 7 	if( ! attach_buffer(x) )\{\
 8 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
 9 		return;\
10 	\} \
11 	b = x->buffy;\
12 	ATOMIC_INCREMENT(&b->b_inuse);\
13       if (!b->b_valid) \{\
14 		ATOMIC_DECREMENT(&b->b_inuse);\
15 		post("bed fade-in: not a valid buffer!");\
16     		return;\
17 	\}\
18 	fadeframes = fadetime * 0.001 * b->b_sr;\
19 	if(fadetime <= 0 || fadeframes > b->b_frames)\{\
20 		post("bed: bad fade time: %f", fadetime);\
21 		ATOMIC_DECREMENT(&b->b_inuse);\
22 		return;\
23 	\}	\
24 	chunksize = fadeframes * b->b_nchans * sizeof(float);\
25 	if( x->undo_samples == NULL )\{\
26 		x->undo_samples = (float *) sysmem_newptr(chunksize);\
27 	\} else \{\
28 		x->undo_samples = \
29 		(float *) sysmem_resizeptr(x->undo_samples, chunksize);\
30 	\}\
31 	if(x->undo_samples == NULL)\{\
32 		post("bed: cannot allocate memory for undo");\
33 		x->can_undo = 0;\
34 		ATOMIC_DECREMENT(&b->b_inuse);\
35 		return;\
36 	\} else \{\
37 		x->can_undo = 1;\
38 		x->undo_start = 0;\
39 		x->undo_frames = fadeframes;\
40 		x->undo_resize = 0;\
41 		sysmem_copyptr(b->b_samples, x->undo_samples,  \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 42 	\}\
43 	for(i = 0; i < fadeframes; i++)\{\
44 		for(j = 0; j < b->b_nchans; j++)\{\
45 			b->b_samples[(i * b->b_nchans) + j] \
				*= (float)i / (float) fadeframes;\
46 		\}\
47 	\}	\
48 	object_method(&b->b_obj, gensym("dirty"));\
49 	ATOMIC_DECREMENT(&b->b_inuse);\
50 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.18
\f0\b0  The fade-in method\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 long		undo_cut; // flag that last operation was a cut\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.19
\f0\b0  The new \'93undo cut\'94 flag component of the object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void bed_cut(t_bed *x, double start, double end)\
 2 \{\
 3 	t_buffer *b;\
 4 	long chunksize; // size of memory alloc in bytes\
 5 	long cutframes; // frames to cut\
 6 	long startframe, endframe;\
 7 	t_atom rv; // return value, needed for message call\
 8 	long offset1, offset2;\
 9 	float *local_samples;\
10 	long local_frames;\
11 	\
12 	if( ! attach_buffer(x) )\{\
13 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
14 		return;\
15 	\} \
16 	b = x->buffy;\
17 	ATOMIC_INCREMENT(&b->b_inuse);\
18    	if (!b->b_valid) \{\
19 		ATOMIC_DECREMENT(&b->b_inuse);\
20 		post("bed normalize: not a valid buffer!");\
21     	return;\
22 	\}\
23 	startframe = start * 0.001 * b->b_sr;\
24 	endframe = end * 0.001 * b->b_sr;\
25 	cutframes = endframe - startframe;\
26 	if(cutframes <= 0 || cutframes > b->b_frames)\{\
27 		post("bed: bad cut data: %f %f", start, end);\
28 		ATOMIC_DECREMENT(&b->b_inuse);\
29 		return;\
30 	\}	\
31 	x->undo_frames = cutframes;\
32 	local_frames = b->b_frames;\
33 	chunksize = local_frames * b->b_nchans * sizeof(float);\
34 	local_samples = (float *) sysmem_newptr(chunksize);\
35 	sysmem_copyptr(b->b_samples, local_samples,  chunksize);\
36 	if(local_samples == NULL)\{\
37 		post("bed: cannot store local samples");\
38 		x->can_undo = 0;\
39 		ATOMIC_DECREMENT(&b->b_inuse);\
40 		return;\
41 	\} \
42 	chunksize = cutframes * b->b_nchans * sizeof(float);	\
43 	if( x->undo_samples == NULL )\{\
44 		x->undo_samples = (float *) sysmem_newptr(chunksize);\
45 	\} else \{\
46 		x->undo_samples = \
		(float *) sysmem_resizeptr(x->undo_samples, chunksize);\
47 	\}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.20
\f0\b0  The cut method \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\page 48 	if(x->undo_samples == NULL)\{\
49 		post("bed: cannot allocate memory for undo");\
50 		x->can_undo = 0;\
51 		ATOMIC_DECREMENT(&b->b_inuse);\
52 		return;\
53 	\} else \{\
54 		x->can_undo = 1;\
55 		x->undo_start = startframe; // start frame\
56 		x->undo_frames = cutframes;\
57 		x->undo_resize = 1;\
58 		sysmem_copyptr(b->b_samples + (startframe * b->b_nchans), 			x->undo_samples,  chunksize);\
59 	\}\
60 	ATOMIC_DECREMENT(&b->b_inuse);\
61 	object_method_long(&b->b_obj, gensym("sizeinsamps"), \
62 		(b->b_frames - cutframes), &rv);\
63 	ATOMIC_INCREMENT(&b->b_inuse);\
64 	chunksize = startframe * b->b_nchans * sizeof(float);\
65 	sysmem_copyptr(local_samples, b->b_samples,  chunksize);\
66 	chunksize = (local_frames - endframe) * \
67 		b->b_nchans * sizeof(float);\
68 	offset1 = startframe * b->b_nchans;\
69 	offset2 = endframe * b->b_nchans;\
70 	sysmem_copyptr(local_samples + offset2, \
71 		b->b_samples + offset1,  chunksize);\
72 	object_method(&b->b_obj, gensym("dirty"));\
73 	ATOMIC_DECREMENT(&b->b_inuse);\
74 	sysmem_freeptr(local_samples);\
75 	x->undo_cut = 1;\
76 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.20 (continued)
\f0\b0 \
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 int attach_any_buffer(t_buffer **b, t_symbol *b_name)\
 2 \{\
 3 	t_object *o;\
 4 	o = b_name->s_thing;\
 5 	if(o == NULL)\{\
 6 		post("There is no object called %s",b_name->s_name);\
 7 		return 0;\
 8 	\}\
 9 	if (ob_sym(o) == gensym("buffer~")) \{\
10 		*b = (t_buffer *) o;\
11 		return 1;\
12 	\} \
13 	else \{\
14 		post("%s is not a buffer", b_name->s_name);\
15 		return 0;\
16 	\}\
17 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.21
\f0\b0  A utility function to attach any buffer\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void bed_paste(t_bed *x, t_symbol *destname)\
 2 \{\
 3 	t_buffer *destbuf = NULL;\
 4 	t_atom rv; // return value\
 5 	long chunksize;\
 6 	if(x->can_undo && x->undo_cut)\{\
 7 		if( ! attach_buffer(x) )\{\
 8 			post("bed: %s is not a valid buffer",\
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->b_name->s_name);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  9 			return;\
10 		\} \
11 		if( attach_any_buffer(&destbuf, destname) )\{		\
12 			if(destbuf->b_nchans != x->buffy->b_nchans)\{\
\pard\pardeftab720\li2880\fi-2880\ri0\ql\qnatural
\cf0 13 	post("bed: channel mismatch between %s and %s", \
\pard\pardeftab720\li2880\ri0\ql\qnatural
\cf0 destname->s_name, x->b_name->s_name);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 14 				return;\
15 			\}			\
16 			object_method_long(&destbuf->b_obj,\
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 gensym("sizeinsamps"), x->undo_frames, &rv);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 			ATOMIC_INCREMENT(&destbuf->b_inuse);\
18 			chunksize = \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->undo_frames * destbuf->b_nchans * sizeof(float);\
\pard\pardeftab720\li2160\fi-2160\ri0\ql\qnatural
\cf0 19 	sysmem_copyptr(x->undo_samples, destbuf->b_samples, chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 20 			ATOMIC_DECREMENT(&destbuf->b_inuse);\
21 		\}\
22 		else\{\
23 			post("bed: %s is not a valid buffer", \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 destname->s_name);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 24 		\}\
25 	\} \
26 	else \{\
27 		post("bed: nothing to paste");\
28 	\}\
29 	\
30 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.22
\f0\b0  The paste method\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 if(x->undo_cut)\{\
 2 	local_frames = b->b_frames;\
 3 	chunksize = local_frames * b->b_nchans * sizeof(float);\
 4 	local_samples = (float *) sysmem_newptr(chunksize);\
 5 	sysmem_copyptr(b->b_samples, local_samples,  chunksize);\
 6 	ATOMIC_DECREMENT(&b->b_inuse);\
 7 	object_method_long(&b->b_obj, gensym("sizeinsamps"), \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 x->undo_frames + local_frames, &rv);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  8 	ATOMIC_INCREMENT(&b->b_inuse);\
 9 	chunksize = x->undo_start * b->b_nchans * sizeof(float);\
10 	sysmem_copyptr(local_samples, b->b_samples, chunksize);\
11 	chunksize = x->undo_frames * b->b_nchans * sizeof(float);\
12 	offset = x->undo_start * b->b_nchans;\
\pard\pardeftab720\li720\fi-720\ri0\ql\qnatural
\cf0 13 	sysmem_copyptr(x->undo_samples, b->b_samples + offset, chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 14 	chunksize = \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 (local_frames - x->undo_start) * b->b_nchans * sizeof(float);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 15 	offset = (x->undo_start + x->undo_frames) * b->b_nchans;\
16 	sysmem_copyptr(local_samples + (x->undo_start * b->b_nchans),\
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 b->b_samples + offset, chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 	ATOMIC_DECREMENT(&b->b_inuse);\
18 	x->undo_cut = 0;\
19 	sysmem_freeptr(local_samples);\
20 	return;\
21 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.24
\f0\b0  Enabling 
\f1\fs20 bed_undo()
\f0\fs24  to reverse cut operations\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void bed_dblclick(t_bed *x)\
 2 \{\
 3 	t_buffer *b;\
 4 	if( ! attach_buffer(x) )\{\
 5 		object_post(&b->b_obj, "%s is not a valid buffer",\
 6 		x->b_name->s_name);\
 7 		return;\
 8 	\} \
 9 	b = x->buffy;\
10 	object_method((t_object *)b, gensym("dblclick"));	\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.25
\f0\b0  Implementing double-click functionality\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 class_addmethod(c, (method)bed_dblclick, "dblclick", A_CANT, 0);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.26
\f0\b0  Binding 
\f1\fs20 bed_dblclick()\
\
\page typedef struct _bed \
\{\
	t_object	x_obj; // the Max object\
	t_symbol	*b_name; // the name of the buffer\
	t_garray	*buffy; // the Buffer\
	long		b_valid; // state of the buffer\
	long		b_frames; // frame count \
	float		*b_samples; // samples\
	float		b_1oversr; // 1 over the sampling rate\
	float		*undo_samples; // samples to undo previous op\
	long		undo_start; // start frame for the undo replace\
	long		undo_frames; // how many frames in the undo\
	long		can_undo; // flag that an undo is possible\
	long		undo_resize; // flag undo will resize buffer\
	long		undo_cut; // flag to un\
	float		b_sr; // sampling rate\
\} t_bed;\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.27
\f0\b0  The object structure for the Pd version of 
\i bed\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 void bed_setup(void)\
 2 \{	\
 3 	t_class *c;\
 4 	\
 5 	bed_class = class_new(gensym("bed"), (t_newmethod)bed_new, 	(t_method)bed_free, sizeof(t_bed), 0, A_SYMBOL, 0); \
 6 	c = bed_class;\
 7    class_addmethod(c, (t_method)bed_info, gensym("info"), \
		A_CANT, 0);	\
 8 	class_addmethod(c, (t_method)bed_normalize, \
		gensym("normalize"), 0);\
 9 	class_addmethod(c, (t_method)bed_fadein, gensym("fadein"), 				A_FLOAT, 0);\
10 	class_addmethod(c, (t_method)bed_cut, gensym("cut"), A_FLOAT, 			A_FLOAT, 0);\
11 	class_addmethod(c, (t_method)bed_paste, gensym("paste"), 				A_SYMBOL, 0);\
12 	class_addmethod(c, (t_method)bed_undo,gensym("undo"),A_CANT,0);\
13 	post("bed - from Designing Audio Objects for Max/MSP and Pd");\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.28
\f0\b0  The initialization routine for 
\i bed
\i0  in Pd
\f4 \
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 int attach_buffer(t_bed *x)\
 2 \{\
 3 	t_garray *a;\
 4 	t_symbol *b_name;\
 5 	float *b_samples;\
 6 	int b_frames;\
 7 	b_name = x->b_name;\
 8 	x->b_valid = 0;\
 9 	if (!(a = (t_garray *)pd_findbyclass(b_name, garray_class))) \{\
10 		if (b_name->s_name)\{\
11 			pd_error(x, "bed: %s: no such array",b_name->s_name);\
12 		\}\
13 		return x->b_valid;\
14     \}\
15 	if (!garray_getfloatarray(a, &b_frames, &b_samples)) \{\
16 		pd_error(x, "bed: bad array for %s", b_name->s_name);\
17 		return x->b_valid;\
18    \}\
19 	else  \{\
20 		x->b_valid = 1;\
21 		x->b_frames = (long)b_frames;\
22 		x->b_samples = b_samples;	\
23 		x->b_sr = sys_getsr();\
24 		if(x->b_sr <= 0)\{\
25 			x->b_sr = 44100.0;\
26 		\}\
27 		x->b_1oversr = 1.0 / x->b_sr;\
28 		x->buffy = a;\
29 	\}\
30 	return x->b_valid;\
31 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.29
\f0\b0  The Pd version of 
\f1\fs20 attach_buffer()\
\
\
\page  1 void bed_undo(t_bed *x)\
 2 \{\
 3 	t_garray *a;\
 4 	long chunksize; // size of memory alloc in bytes\
 5 	float *local_samples; // for undoing a cut\
 6 	long local_frames;\
 7 	long offset;\
 8 	long oldsize; // Pd bookkeeping\
 9 	if(! x->can_undo )\{\
10 		post("bed: nothing to undo");\
11 		return;\
12 	\}	\
13 	if( ! attach_buffer(x) )\{\
14 		post("bed: %s is not a valid buffer",x->b_name->s_name);\
15 		return;\
16 	\} \
17 	a = x->buffy;\
18 	// take care of special case for undo cut\
19 	if(x->undo_cut)\{\
20 		// copy everything to local buffer\
21 		local_frames = x->b_frames;\
22 		chunksize = local_frames * sizeof(float);\
23 		local_samples = getbytes(chunksize);\
24 		memcpy(local_samples, x->b_samples, chunksize);\
25 		// now resize buffer to incorporate cut segment\
26 		garray_resize(a, x->undo_frames + local_frames);\
27 		// copy first part of buffer back\
28 		chunksize = x->undo_start * sizeof(float);\
29 		memcpy(x->b_samples, local_samples, chunksize);\
30 		// now copy the cut piece back in\
31 		chunksize = x->undo_frames * sizeof(float);\
32 		memcpy(x->b_samples + x->undo_start, x->undo_samples, 				chunksize);\
33 		// finally, add the last piece from the original\
34 		chunksize = (local_frames - x->undo_start) * \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 sizeof(float);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 35 		offset = x->undo_start + x->undo_frames;\
36 		memcpy(x->b_samples + offset, \
			local_samples + x->undo_start,  chunksize);\
37 		x->undo_cut = 0;\
38 		oldsize = local_frames * sizeof(float);\
39 		freebytes(local_samples, oldsize);\
40 		garray_redraw(a);\
41 		return;\
42 	\}\
43 	chunksize = x->undo_frames * sizeof(float);\
44 	if(x->undo_resize)\{\
45 		garray_resize(a, x->undo_frames);\
46 	\}\
47 	// copy old samples back into (possibly resized) buffer\
48 	memcpy(x->b_samples + x->undo_start, x->undo_samples, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 chunksize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 49 	// now nothing left to undo\
50 	x->can_undo = 0;\
51 	garray_redraw(a);\
52 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.30
\f0\b0  The undo method for 
\i bed
\i0  in Pd\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs18 \cf0 \page  1 void bed_cut(t_bed *x, t_floatarg start, t_floatarg end)
\fs20 \

\fs18  2 \{
\fs20 \

\fs18  3 	t_garray *a;
\fs20 \

\fs18  4 	long chunksize; // size of memory alloc in bytes
\fs20 \

\fs18  5 	long oldsize; // Pd bookkeeping
\fs20 \

\fs18  6 	long cutframes; // frames to cut
\fs20 \

\fs18  7 	long startframe, endframe;
\fs20 \

\fs18  8 	float *local_samples;
\fs20 \

\fs18  9 	long local_frames;
\fs20 \

\fs18 10 	if( ! attach_buffer(x) )\{
\fs20 \

\fs18 11 		post("bed: %s is not a valid buffer",x->b_name->s_name);
\fs20 \

\fs18 12 		return;
\fs20 \

\fs18 13 	\} 
\fs20 \

\fs18 14 	a = x->buffy;
\fs20 \

\fs18 15 	startframe = start * 0.001 * x->b_sr;
\fs20 \

\fs18 16 	endframe = end * 0.001 * x->b_sr;
\fs20 \

\fs18 17 	cutframes = endframe - startframe;
\fs20 \

\fs18 18 	if(cutframes <= 0 || cutframes > x->b_frames)\{
\fs20 \

\fs18 19 		post("bed: bad cut data: %f %f", start, end);
\fs20 \

\fs18 20 		return;
\fs20 \

\fs18 21 	\}	
\fs20 \

\fs18 22 	x->undo_frames = cutframes;
\fs20 \

\fs18 23 	local_frames = x->b_frames;
\fs20 \

\fs18 24 	// store samples for undo (copy everything)
\fs20 \

\fs18 25 	chunksize = local_frames * sizeof(float); // all arrays are mono
\fs20 \

\fs18 26 	local_samples = getbytes(chunksize); // use Pd memory function
\fs20 \

\fs18 27 	memcpy(local_samples, x->b_samples, chunksize); // C lib function
\fs20 \

\fs18 28 	chunksize = cutframes * sizeof(float);
\fs20 \

\fs18 29 	if( x->undo_samples == NULL )\{
\fs20 \

\fs18 30 		x->undo_samples = getbytes(chunksize);
\fs20 \

\fs18 31 	\} else \{
\fs20 \

\fs18 32 		oldsize = x->undo_frames * sizeof(float);
\fs20 \

\fs18 33 		x->undo_samples = resizebytes(x->undo_samples, oldsize, 
\fs20 \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural

\fs18 \cf0 chunksize);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 34 	\}
\fs20 \

\fs18 35 	if(x->undo_samples == NULL)\{
\fs20 \

\fs18 36 		post("bed: cannot allocate memory for undo");
\fs20 \

\fs18 37 		x->can_undo = 0;
\fs20 \

\fs18 38 		return;
\fs20 \

\fs18 39 	\} else \{
\fs20 \

\fs18 40 		x->can_undo = 1;
\fs20 \

\fs18 41 		x->undo_start = startframe; // start frame
\fs20 \

\fs18 42 		x->undo_frames = cutframes;
\fs20 \

\fs18 43 		x->undo_resize = 1;
\fs20 \

\fs18 44 		memcpy(x->undo_samples, x->b_samples + startframe, chunksize);
\fs20 \

\fs18 45 	\}
\fs20 \

\fs18 46 	garray_resize(a, (x->b_frames - cutframes));
\fs20 \

\fs18 47 	// copy up to the start of the cut
\fs20 \

\fs18 48 	chunksize = startframe * sizeof(float);
\fs20 \

\fs18 49 	memcpy(x->b_samples, local_samples, chunksize);
\fs20 \

\fs18 50 	chunksize = (local_frames - endframe) * sizeof(float);
\fs20 \

\fs18 51 	memcpy(x->b_samples + startframe, local_samples + endframe, 
\fs20 \
\pard\pardeftab720\li1440\ri0\ql\qnatural

\fs18 \cf0 chunksize);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 52 	// free local memory
\fs20 \

\fs18 53 	oldsize = local_frames * sizeof(float);
\fs20 \

\fs18 54 	freebytes(local_samples, oldsize);
\fs20 \

\fs18 55 	x->undo_cut = 1;
\fs20 \

\fs18 56 	garray_redraw(x->buffy);	
\fs20 \

\fs18 57 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.31
\f0\b0  The Pd version of 
\f1\fs20 bed_cut()\
\
\page  1 int attach_any_buffer(t_garray **dest_array, t_symbol *b_name)\
 2 \{\
 3 	t_garray *a;\
 4 	int b_valid = 0;\
 5 	if (!(a = (t_garray *)pd_findbyclass(b_name, garray_class))) \{\
 6 		if (b_name->s_name) post("ben: %s: no such array",\
		b_name->s_name);\
 7 		return 0;\
 8     \} else \{\
 9 		b_valid = 1;\
10 	\}\
11 	*dest_array = a;\
12 	return b_valid;\
13 \}\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.32
\f0\b0  The Pd version of 
\f1\fs20 attach_any_buffer()\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  1 void bed_paste(t_bed *x, t_symbol *destname)
\fs20 \

\fs18  2 \{
\fs20 \

\fs18  3 	t_garray *a;
\fs20 \

\fs18  4 	t_garray *destbuf = NULL;
\fs20 \

\fs18  5 	long chunksize;
\fs20 \

\fs18  6 	int destbuf_b_frames;
\fs20 \

\fs18  7 	float *destbuf_b_samples;
\fs20 \

\fs18  8 	if(x->can_undo)\{
\fs20 \

\fs18  9 		if( ! attach_buffer(x) )\{
\fs20 \

\fs18 10 			post("bed: %s is not a valid buffer",
\fs20 \

\fs18 			x->b_name->s_name);
\fs20 \

\fs18 11 			return;
\fs20 \

\fs18 12 		\} 
\fs20 \

\fs18 13 		if( attach_any_buffer(&destbuf, destname) )\{
\fs20 \

\fs18 14 			if (!garray_getfloatarray(destbuf, &destbuf_b_frames, 				&destbuf_b_samples)) \{
\fs20 \

\fs18 15 				pd_error(x, "bed: bad array for %s", 
\fs20 \

\fs18 					destname->s_name);
\fs20 \

\fs18 16 				return;
\fs20 \

\fs18 17 			\}
\fs20 \

\fs18 18 			garray_resize(destbuf, x->undo_frames);
\fs20 \

\fs18 19 			chunksize = x->undo_frames * sizeof(float);
\fs20 \

\fs18 20 			if (!garray_getfloatarray(destbuf, &destbuf_b_frames, 				&destbuf_b_samples)) \{
\fs20 \

\fs18 21 				pd_error(x, "bed: bad array for %s", 
\fs20 \

\fs18 				destname->s_name);
\fs20 \

\fs18 22 				return;
\fs20 \

\fs18 23 			\}
\fs20 \

\fs18 24 			memcpy(destbuf_b_samples,x->undo_samples,chunksize);
\fs20 \

\fs18 25 			garray_redraw(destbuf);
\fs20 \

\fs18 26 		\}
\fs20 \

\fs18 27 		else\{
\fs20 \

\fs18 28 			post("bed: %s is not a valid buffer", 
\fs20 \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural

\fs18 \cf0 destname->s_name);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 29 		\}
\fs20 \

\fs18 30 	\} else \{
\fs20 \

\fs18 31 		post("bed: nothing to paste");
\fs20 \

\fs18 32 	\}
\fs20 \

\fs18 33 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 7.33
\f0\b0  The Pd version of 
\f1\fs20 bed_paste()\

\f0\fs24 \page   
\f1\fs20 1 t_int *cleaner_perform(t_int *w)\
 2 \{\
 3 	t_float *input = (t_float *) (w[1]);\
 4 	t_float *threshmult = (t_float *) (w[2]);\
 5 	t_float *multiplier = (t_float *) (w[3]);\
 6 	t_float *output = (t_float *) (w[4]);\
 7 	t_int n = w[5];\
 8 	float maxamp = 0.0;\
 9 	float threshold; \
10 	float mult; \
11 	int i;\
12 	for(i = 0; i < n; i++)\{\
13 		if(maxamp < input[i])\{\
14 			maxamp = input[i];\
15 		\}\
16 	\}\
17 	threshold = *threshmult * maxamp;\
18 	mult = *multiplier;\
19 	for(i = 0; i < n; i++)\{\
20 		if(input[i] < threshold)\{\
21 			input[i] *= mult;\
22 		\}		\
23 		output[i] = input[i];\
24 	\}\
25 	return w + 6;\
26 \}\
\
_____________________________________________________________________
\f0\fs24 \

\f3\b Figure 8.2
\f4\b0  Adaptive noise reduction coded in C\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 while(phase > PI)\{\
2 	phase -= TWOPI;\
3 \}\
4 while(phase < -PI)\{\
5 	phase += TWOPI;\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.8
\f0\b0  Implementing phase wrapping in C code\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #define SCRUBBER_EMPTY 0\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 #define SCRUBBER_FULL 1\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.10
\f0\b0  
\i scrubber~
\i0  buffer state constants\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page typedef struct _scrubber \{\
	t_pxobject obj; // Max/MSP proxy object\
	float **amplitudes; // contains spectral frames\
	float **phases; // contains spectral frames\
	float duration_ms; // duration in milliseconds\
	long recorded_frames; // counter for recording of frames\
	long framecount; // total frames in spectrum\
	long oldframes; // for resizing memory\
	long fftsize; // number of bins in a frame\
	float sr; // sampling rate\
	float frame_position; // current frame\
	float increment; // speed to advance through the spectrum\
	short acquire_sample; //flag to begin sampling\
	float sync; // location in buffer (playback or recording)\
	float overlap;// overlap factor for STFT\
	short buffer_status; // empty or full\
	float last_position; //last spectrum position (scaled 0-1)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \} t_scrubber;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.11
\f0\b0  The 
\i scrubber~
\i0  object structure\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void scrubber_init_memory(t_scrubber *x)\
 2 \{\
 3 	long framecount = x->framecount;\
 4 	long oldframes = x->oldframes;\
 5 	long fftsize = x->fftsize;\
 6 	long framesize = fftsize / 2;\
 7 	long bytesize;\
 8 	int i;\
 9 	if(framecount <= 0)\{\
10 		post("scrubber~: bad frame count: %d", framecount);\
11 		return;\
12 	\}\
13 	if(fftsize <= 0)\{\
14 		post("scrubber~: bad size: %d", fftsize);\
15 		return;\
16 	\}\
17 	x->buffer_status = SCRUBBER_EMPTY; \
18 	if(x->amplitudes == NULL)\{\
19 		bytesize = framecount * sizeof(float *);\
20 		x->amplitudes = (float **) sysmem_newptr(bytesize);\
21 		x->phases = (float **) sysmem_newptr(bytesize);\
22 		bytesize = framesize * sizeof(float);\
23 		for(i = 0; i < framecount; i++)\{\
24 			x->amplitudes[i] = (float *) \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 sysmem_newptr(bytesize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 25 			x->phases[i] = (float *) sysmem_newptr(bytesize);\
26 		\}\
27 	\} \
28 	else \{\
29 		for(i = 0; i < oldframes; i++)\{\
30 			sysmem_freeptr(x->amplitudes[i]);\
31 			sysmem_freeptr(x->phases[i]);\
32 		\}\
33 		bytesize = framecount * sizeof(float *);\
34 		x->amplitudes = \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (float **)sysmem_resizeptr(x->amplitudes, bytesize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 35 		x->phases = \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (float **)sysmem_resizeptr(x->phases, bytesize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 36 		bytesize = framesize * sizeof(float);\
37 		for(i = 0; i < framecount; i++)\{\
38 			x->amplitudes[i] = (float *)\
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 sysmem_newptr(bytesize);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 39 			x->phases[i] = (float *)sysmem_newptr(bytesize);\
40 		\}\
41 		x->oldframes = framecount;\
42 	\}\
43 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.12
\f0\b0  The memory allocation routine\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void *scrubber_new(t_symbol *s, int argc, t_atom *argv)\
 2 \{\
 3 	t_scrubber *x = (t_scrubber *)object_alloc(scrubber_class);\
 4 	dsp_setup((t_pxobject *)x, 4);\
 5 	outlet_new((t_object *)x, "signal");\
 6 	outlet_new((t_object *)x, "signal");\
 7 	outlet_new((t_object *)x, "signal");\
 8 	x->amplitudes = NULL;\
 9 	x->framecount = 1; // one frame for initialization purposes\
10 	x->acquire_sample = 0;\
11 	x->fftsize = 1024;\
12 	x->frame_position = 0;\
13 	x->oldframes = 0;\
14 	x->duration_ms = 5000.0; // default size\
15 	x->buffer_status = SCRUBBER_EMPTY;\
16 	if( argc >= 1)\{\
17 		x->duration_ms = atom_getfloatarg(0, argc, argv);\
18 	\} \
19 	x->last_position = 0;\
20 	x->overlap = 8.0;	\
21 	x->sr = 44100.0;\
22 	scrubber_init_memory(x);\
23 	return x;\
24 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.13
\f0\b0  The new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 t_int *scrubber_perform(t_int *w)\
 2 \{\
 3 	t_scrubber *x = (t_scrubber *) (w[1]);\
 4 	t_float *mag_in = (t_float *) (w[2]); \
 5 	t_float *phase_in = (t_float *) (w[3]); \
 6 	t_float *increment = (t_float *) (w[4]);\
 7 	t_float *position = (t_float *) (w[5]);\
 8 	t_float *mag_out = (t_float *) (w[6]);\
 9 	t_float *phase_out = (t_float *) (w[7]);\
10 	t_float *sync = (t_float *) (w[8]);\
11 	t_int n = w[9];\
12 	long framecount = x->framecount;\
13 	long recorded_frames = x->recorded_frames;\
14 	float frame_position = x->frame_position;\
15 	float **amplitudes = x->amplitudes;\
16 	float **phases = x->phases;\
17 	int i;\
18 	long iframe_position;\
19 	float sync_val;\
20 	short acquire_sample = x->acquire_sample;\
21 	float last_position = x->last_position;\
22 	\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.14
\f0\b0  The 
\i scrubber~
\i0  perform routine\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\page 23 	if(acquire_sample)\{\
24 		sync_val = (float) recorded_frames / (float) framecount;\
25 		for (i = 0; i < n; i++) \{\
26 			amplitudes[recorded_frames][i] = mag_in[i];\
27 			phases[recorded_frames][i] = phase_in[i];\
28 		\}\
29 		for(i = 0; i < n; i++)\{\
30 			// send silence while sampling\
31 			mag_out[i] = 0.;\
32 			phase_out[i] = 0.;\
33 			sync[i] = sync_val;\
34 		\}\
35 		++recorded_frames;\
36 		if(recorded_frames >= framecount)\{\
37 			acquire_sample = 0;\
38 			x->buffer_status = SCRUBBER_FULL;\
39 		\}\
40 	\} \
41 	else if(x->buffer_status == SCRUBBER_FULL) \{\
42 		sync_val = frame_position / (float) framecount;\
43 		if(last_position != *position && *position >= 0.0 \
			&& *position <= 1.0)\{\
44 			last_position = *position;\
45 			frame_position = last_position * \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 (float)(framecount - 1);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 46 		\}\
47 		frame_position += *increment;\
48 \
49 		while(frame_position < 0.)\{\
50 			frame_position += framecount;\
51 		\}\
52 		while(frame_position >= framecount)\{\
53 			frame_position -= framecount;\
54 		\}\
55 		iframe_position = floor(frame_position);\
56 				\
57 		for (i = 0; i < n; i++) \{\
58 			mag_out[i] = amplitudes[iframe_position][i];\
59 			phase_out[i] = phases[iframe_position][i];\
60 			sync[i] = sync_val;\
61 		\}\
62 	\} \
63 	else \{\
64 		for(i = 0; i < n; i++)\{\
65 			mag_out[i] = 0.0;\
66 			phase_out[i] = 0.0;\
67 			sync[i] = 0.0;\
68 		\}\
69 	\}\
70 	x->last_position = last_position;\
71 	x->frame_position = frame_position;\
72 	x->acquire_sample = acquire_sample;\
73 	x->recorded_frames = recorded_frames;\
74 	return w + 10;\
75 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.14 (continued)
\f0\b0  \
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 void scrubber_sample(t_scrubber *x)\
2 \{\
3 	x->acquire_sample = 1;\
4 	x->recorded_frames = 0;\
5 	x->buffer_status = SCRUBBER_EMPTY;\
6 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.15
\f0\b0  Initiating the sampling process\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void scrubber_dsp(t_scrubber *x, t_signal **sp, short *count)\
 2 \{	\
 3 	long blocksize = sp[0]->s_n;\
 4 	float local_sr = sp[0]->s_sr;\
 5 	long local_fftsize = blocksize * 2;\
 6 	float framedur;\
 7 	long new_framecount;\
 8 	if(!local_sr)\{\
 9 		return;\
10 	\}\
11 	framedur = local_fftsize / x->sr;\
12 	new_framecount = 0.001 * x->duration_ms * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 x->overlap / framedur;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 13 	if(x->fftsize != local_fftsize || x->sr != sp[0]->s_sr || \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->framecount != new_framecount)\{\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 14 		x->fftsize = local_fftsize;\
15 		x->sr = sp[0]->s_sr;\
16 		x->framecount = new_framecount;\
17 		scrubber_init_memory(x);\
18 	\} 	\
19 	dsp_add(scrubber_perform, 9, x,  sp[0]->s_vec, sp[1]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, \
\pard\pardeftab720\li1440\ri0\ql\qnatural
\cf0 sp[6]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 20 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.16
\f0\b0  The dsp method\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void scrubber_overlap(t_scrubber *x, t_symbol *msg, short argc, \
\pard\pardeftab720\li720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	float old_overlap = x->overlap;\
 4 	if(argc >= 1)\{\
 5 		x->overlap = atom_getfloatarg(0,argc,argv);\
 6 		if(x->overlap <= 0)\{\
 7 			post("scrubber~: bad overlap: %f", x->overlap);\
 8 			x->overlap = old_overlap;\
 9 			return;\
10 		\}\
11 		if(x->overlap != old_overlap)\{\
12 			scrubber_init_memory(x);			\
13 		\}\
14 	\}\
15 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.17
\f0\b0  The overlap method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void scrubber_resize(t_scrubber *x, t_symbol *msg, short argc, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *argv)\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	float old_size = x->duration_ms;\
 4 	float framedur;\
 5 	if(argc >= 1)\{\
 6 		x->duration_ms = atom_getfloatarg(0,argc,argv);\
 7 	\} \
 8 	else \{\
 9 		return;\
10 	\}\
11 	if(old_size == x->duration_ms)\{\
12 		return;\
13 	\}\
14 	if(x->duration_ms > 0.0 && x->sr > 0.0 && x->fftsize > 0.0 && \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 x->overlap > 0.0)\{\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 15 		framedur = 2.0 * x->fftsize / x->sr;\
16 		x->oldframes = x->framecount;\
17 		x->framecount = 0.001 * x->duration_ms * \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->overlap / framedur;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 18 		scrubber_init_memory(x);\
19 	\}\
20 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.18
\f0\b0  Resizing the spectral buffer\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void scrubber_free(t_scrubber *x)\
 2 \{\
 3 	int i;\
 4 	dsp_free(&x->obj);\
 5 	if(x->amplitudes != NULL)\{\
 6 		for(i = 0; i < x->framecount; i++)\{\
 7 			sysmem_freeptr(x->amplitudes[i]);\
 8 			sysmem_freeptr(x->phases[i]);\
 9 		\}\
10 		sysmem_freeptr(x->amplitudes);\
11 		sysmem_freeptr(x->phases);\
12 	\} \
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.19
\f0\b0  The 
\f1\fs20 scrubber_free()
\f0\fs24  routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void windowvec_dsp(t_windowvec *x, t_signal **sp, short *count)\
 2 \{\
 3 	int i;\
 4 	float twopi = 8. * atan(1);\
 5 	if(x->vecsize != sp[0]->s_n)\{\
 6 		x->vecsize = sp[0]->s_n;\
 7 		if(x->envelope == NULL)\{\
 8 			x->envelope = (float *) \
			getbytes(x->vecsize * sizeof(float));\
 9 		\} else \{\
10 			x->envelope = (float *) \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 resizebytes(x->envelope, x->oldbytes, \
	x->vecsize * sizeof(float));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 		\}\
12 		x->oldbytes = x->vecsize * sizeof(float);\
13 		for(i = 0 ; i < x->vecsize; i++)\{\
14 			x->envelope[i] = \
			-0.5 * cos(twopi * (i / (float)x->vecsize)) + 0.5;\
15 		\}\
16 	\}\
17 	dsp_add(windowvec_perform, 4, x, sp[0]->s_vec, \
		sp[1]->s_vec, sp[0]->s_n);\
18 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.21
\f0\b0  The dsp routine for 
\i windowvec~\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page  1 t_int *windowvec_perform(t_int *w)\
 2 \{\
 3 	t_windowvec *x = (t_windowvec *) (w[1]);\
 4 	t_float *input = (t_float *) (w[2]);\
 5 	t_float *output = (t_float *) (w[3]);\
 6 	t_int n = w[4];\
 7 	int i;\
 8 	float *envelope = x->envelope;\
 9 	for(i=0; i < n; i++)\{\
10 		output[i] = input[i] * envelope[i];\
11 	\}\
12 	return w + 5;\
13 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.22
\f0\b0  The perform routine for 
\i windowvec~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0  1 t_scrubber *x = (t_scrubber *) (w[1]);\
 2 t_float *real_in = (t_float *) (w[2]); // real\
 3 t_float *imag_in = (t_float *) (w[3]); // imag\
 4 t_float *increment = (t_float *) (w[4]);\
 5 t_float *position = (t_float *) (w[5]);\
 6 t_float *real_out = (t_float *) (w[6]);\
 7 t_float *imag_out = (t_float *) (w[7]);\
 8 t_float *sync = (t_float *) (w[8]);\
 9 t_int n = w[9];\
10 long framecount = x->framecount;\
11 long recorded_frames = x->recorded_frames;\
12 float frame_position = x->frame_position;\
13 float **amplitudes = x->amplitudes;\
14 float **phasediffs = x->phasediffs;\
15 int i;\
16 float real, imag;\
17 long iframe_position;\
18 float sync_val;\
19 short acquire_sample = x->acquire_sample;\
20 float last_position = x->last_position;\
21 float *lastphase_in = x->lastphase_in;	\
22 float *lastphase_out = x->lastphase_out; \
23 float phase_out, mag_out;\
24 float local_phase, phasediff;\
25 int N2 = n / 2; // half of FFT size\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.23
\f0\b0  Inputs to the perform routine\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 if(acquire_sample)\{\
 2 	sync_val = (float) recorded_frames / (float) framecount;\
 3 	for (i = 0; i < N2 + 1; i++) \{\
 4 		real = real_in[i];\
 5 		imag = (i == 0 || i == N2 ? 0. : imag_in[i]);\
 6 		amplitudes[recorded_frames][i] = hypot(real, imag);\
 7 		local_phase = -atan2(imag, real);\
 8 		phasediff = local_phase - lastphase_in[i];\
 9 		lastphase_in[i] = local_phase;\
10 		while(phasediff > PI)\{\
11 			phasediff -= TWOPI;\
12 		\}\
13 		while(phasediff < -PI)\{\
14 			phasediff += TWOPI;\
15 		\}\
16 		phasediffs[recorded_frames][i] = phasediff;\
17 	\}\
18 	for(i = 0; i < n; i++)\{\
19 		real_out[i] = 0.;\
20 		imag_out[i] = 0.;\
21 		sync[i] = sync_val;\
22 	\}\
23 	++recorded_frames;\
24 	if(recorded_frames >= framecount)\{\
25 		acquire_sample = 0;\
26 		x->buffer_status = SCRUBBER_FULL;\
27 	\}\
28 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.24
\f0\b0  The analysis loops\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 else if(x->buffer_status == SCRUBBER_FULL) \{\
 2 	sync_val = frame_position / (float) framecount;\
 3 	if( last_position != *position && *position >= 0.0 \
 4 		&& *position <= 1.0 )\{\
 5 		last_position = *position;\
 6 		frame_position = last_position * (float)(framecount - 1);\
 7 	\}\
 8 	frame_position += *increment;\
 9 	while(frame_position < 0.)\{\
10 		frame_position += framecount;\
11 	\}\
12 	while(frame_position >= framecount)\{\
13 		frame_position -= framecount;\
14 	\}\
15 	iframe_position = floor(frame_position);\
16 	for ( i = 0; i < N2+1; i++ ) \{\
17 		mag_out = amplitudes[iframe_position][i];\
18 		lastphase_out[i] += phasediffs[iframe_position][i];\
19 		local_phase = lastphase_out[i];\
20 		real_out[i] = mag_out * cos(local_phase);\
21 		imag_out[i] = (i == 0 || i == N2) ? 0.0 : -mag_out * \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 sin(local_phase);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 22 		sync[i] = sync_val;\
23 	\}\
24 	for ( i = N2+1; i < n; i++ )\
25 	\{\
26 		real_out[i] = 0.;\
27 		imag_out[i] = 0.;\
28 		sync[i] = sync_val;\
29 	\}\
30 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.25
\f0\b0  The 
\i scrubber~
\i0  resynthesis block\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void scrubber_dsp(t_scrubber *x, t_signal **sp, short *count)\
 2 \{\
 3 	float local_sr = sys_getsr();\
 4 	long local_blocksize = sp[0]->s_n;\
 5 	float framedur;\
 6 	long new_framecount;\
 7 	if(!local_sr)\{\
 8 		return;\
 9 	\}\
10 	framedur = local_blocksize / x->sr;\
11 	new_framecount = 0.001 * x->duration_ms * \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 x->overlap / framedur;\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 12 	if(x->fftsize != local_blocksize || x->sr != local_sr|| \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->framecount != new_framecount) \{\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 13 		x->fftsize = local_blocksize;\
14 		x->sr = local_sr;\
15 		x->framecount = new_framecount;\
16 		scrubber_init_memory(x);\
17 	\}\
18 	dsp_add(scrubber_perform, 9, x,  sp[0]->s_vec, sp[1]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[4]->s_vec, \
\pard\pardeftab720\li1440\ri0\ql\qnatural
\cf0 sp[5]->s_vec, sp[6]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 19 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.26
\f0\b0  The 
\i scrubber~
\i0  dsp method for Pd\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 void scrubber_init_memory(t_scrubber *x)\
 2 \{\
 3 	long framecount = x->framecount;\
 4 	long oldframes = x->oldframes;\
 5 	long fftsize = x->fftsize;\
 6 	long fftsize2 = fftsize / 2;\
 7 	int i;\
 8 	long bytesize;\
 9 	if(framecount <= 0)\{\
10 		post("bad frame count: %d", framecount);\
11 		return;\
12 	\}\
13 	if(fftsize <= 0)\{\
14 		post("bad size: %d", fftsize);\
15 		return;\
16 	\}\
17 	x->buffer_status = SCRUBBER_EMPTY;\
18 	bytesize = framecount * sizeof(float *);\
19 	if(x->amplitudes == NULL)\{\
20 		x->amplitudes = (float **) malloc(bytesize);\
21 		x->phasediffs = (float **) malloc(bytesize);\
22 		bytesize = (fftsize2 + 1) * sizeof(float);\
23 		for(i = 0; i < framecount; i++)\{\
24 			x->amplitudes[i] = (float *) malloc(bytesize);\
25 			x->phasediffs[i] = (float *) malloc(bytesize);\
26 		\}\
27 		x->lastphase_in = (float *) malloc(bytesize);\
28 		x->lastphase_out = (float *) malloc(bytesize);\
29 		memset(x->lastphase_in, 0, bytesize);\
30 		memset(x->lastphase_out, 0, bytesize);\
31 	\} \
32 	else \{\
33 		for(i = 0; i < oldframes; i++)\{\
34 			free(x->amplitudes[i]);\
35 			free(x->phasediffs[i]);\
36 		\}\
37 		bytesize = framecount * sizeof(float *);\
38 		x->amplitudes = (float **)realloc(x->amplitudes, bytesize);\
39 		x->phasediffs = (float **)realloc(x->phasediffs, bytesize);\
40 		bytesize = (fftsize2 + 1) * sizeof(float);\
41 		for(i = 0; i < framecount; i++)\{\
42 			x->amplitudes[i] = (float*)malloc(bytesize);\
43 			x->phasediffs[i] = (float*)malloc(bytesize);\
44 		\}\
45 		x->lastphase_in = \
			(float *) realloc(x->lastphase_in, bytesize);\
46 		x->lastphase_out = \
			(float *) realloc(x->lastphase_out, bytesize);\
47 		memset(x->lastphase_in, 0, bytesize);\
48 		memset(x->lastphase_out, 0, bytesize);\
49 	\}\
50 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.27
\f0\b0  Coding memory storage for Pd using standard C library functions\
\
\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void scrubber_free(t_scrubber *x)\
 2 \{\
 3 	int i;\
 4 	if(x->amplitudes != NULL)\{\
 5 		for(i = 0; i < x->framecount; i++)\{\
 6 			free(x->amplitudes[i]);\
 7 			free(x->phasediffs[i]);\
 8 		\}\
 9 		free(x->amplitudes);\
10 		free(x->phasediffs);\
11 		free(x->lastphase_in);\
12 		free(x->lastphase_out);\
13 	\} \
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 8.28
\f0\b0  The free function using standard C functions\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 t_int *vpdelay_perform(t_int *w)\
 2 \{\
 3 	t_vpdelay *x = (t_vpdelay *) (w[1]);\
 4 	t_float *input = (t_float *) (w[2]);\
 5 	t_float *delaytime = (t_float *) (w[3]);\
 6 	t_float *feedback = (t_float *) (w[4]);\
 7 	t_float *output = (t_float *) (w[5]);\
 8 	t_int n = w[6];\
 9 	float sr = x->sr;\
10 	float *delay_line = x->delay_line;\
11 	float *read_ptr  = x->read_ptr;\
12 	float *write_ptr = x->write_ptr;\
13 	long delay_length = x->delay_length;\
14 	float *endmem = delay_line + delay_length;\
15 	short delaytime_connected = x->delaytime_connected;\
16 	short feedback_connected = x->feedback_connected;\
17 	float delaytime_float = x->delay_time;\
18 	float feedback_float = x->feedback;	\
19 	float fraction;\
20 	float fdelay;\
21 	float samp1, samp2;\
22 	long idelay;\
23 	float srms = sr / 1000.0;\
24 	float out_sample, feedback_sample;\
25 	while(n--)\{\
26 		if(delaytime_connected)\{\
27 			fdelay = *delaytime++ * srms;\
28 		\}\
29 		else \{ \
30 			fdelay = delaytime_float * srms; \
31 		\}\
32 		while(fdelay > delay_length)\{\
33 			fdelay -= delay_length;\
34 		\}\
35 		while(fdelay < 0)\{\
36 			fdelay += delay_length;\
37 		\}\
38 		idelay = trunc(fdelay);\
39 		fraction = fdelay - idelay;\
40 		read_ptr = write_ptr - idelay;\
41 		while(read_ptr < delay_line)\{\
42 			read_ptr += delay_length;\
43 		\}\
44 		samp1 = *read_ptr++;\
45 		if(read_ptr == endmem)\{\
46 			read_ptr = delay_line;\
47 		\}\
48 		samp2 = *read_ptr;\
49 		out_sample = samp1 + fraction * (samp2-samp1);\
\
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 9.1
\f0\b0  A perform routine for 
\i vpdelay~
\i0  using pointers to access the delay line\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\page 50 		if(feedback_connected) \{\
51 			feedback_sample = out_sample * *feedback++;\
52 		\}\
53 		else \{ \
54 			feedback_sample = out_sample * feedback_float;\
55 		\}	\
56 		if(fabs(feedback_sample) < 0.0000001)\{\
57 			feedback_sample = 0.0;\
58 		\}\
59 		*write_ptr++ = *input++ + feedback_sample;\
60 		*output++ = out_sample;\
61 		if(write_ptr == endmem)\{\
62 			write_ptr = delay_line;\
63 		\}\
64 	\}\
65 	x->write_ptr = write_ptr;\
66 	return w + 7;\
67 \}\
_____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 9.1 (continued)
\f0\b0  \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 x->write_ptr = x->delay_line;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.2
\f0\b0  Assigning the write pointer to the start of the delay line\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 var ocnt = 200;\
 2 var p = this.patcher;\
 3 function build()\
 4 \{\
 5 	var i;\
 6 	var h = 20, v = 20;\
 7 	var source = p.newdefault(h,v,"cycle~","440");\
 8 	var newdel;\
 9 	v += 30;\
10 	for(i = 0; i < ocnt; i++)\{\
11 		newdel = p.newdefault(h,v,"vpdelay~", 10, 10, 0.5);\
12 		p.connect(source, 0, newdel, 0);\
13 	\}\
14 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.3
\f0\b0  JavaScript code for benchmarking 
\i vpdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page 	if(delaytime_connected && feedback_connected)\{\
// DSP loop for both connected\
	\} \
	else if(delaytime_connected)\{\
// DSP loop for only delay time connected\
	\}\
	else if(feedback_connected)\{\
// DSP loop for feedback connected\
	\}\
	else \{\
// DSP loop for neither connected.\
	\}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.4
\f0\b0  Branching structure to select most efficient processing scheme\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 else \{\
 2 	fdelay = delaytime_float * srms;\
 3 	while(fdelay > delay_length)\{\
 4 		fdelay -= delay_length;\
 5 	\}\
 6 	while(fdelay < 0)\{\
 7 		fdelay += delay_length;\
 8 	\}\
 9 	idelay = trunc(fdelay);\
10 	fraction = fdelay - idelay;\
11 	while(n--)\{\
12 		read_ptr = write_ptr - idelay;\
13 		while(read_ptr < delay_line)\{\
14 			read_ptr += delay_length;\
15 		\}\
16 		samp1 = *read_ptr++;\
17 		if(read_ptr == endmem)\{\
18 			read_ptr = delay_line;\
19 		\}\
20 		samp2 = *read_ptr;\
21 		out_sample = samp1 + fraction * (samp2-samp1);\
22 		feedback_sample = out_sample * feedback_float;	\
23 		if(fabs(feedback_sample) < 0.0000001)\{\
24 			feedback_sample = 0.0;\
25 		\}\
26 		*write_ptr++ = *input++ + feedback_sample;\
27 		*output++ = out_sample;\
28 		if(write_ptr == endmem)\{\
29 			write_ptr = delay_line;\
30 		\}\
31 	\}\
32 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.5
\f0\b0  The DSP branch where neither delay time nor feedback input is a signal\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 function build_both_connected()\
 2 \{\
 3 	var i;\
 4 	var h = 20, v = 20;\
 5 	var source = p.newdefault(h,v,"cycle~", "440");\
 6 	var sdel = p.newdefault(h+100,v, "sig~", 2.0);\
 7 	var sfeed= p.newdefault(h+200,v, "sig~", 0.5);\
 8 	var newdel;\
 9 	v += 30;\
10 	for(i = 0; i < ocnt; i++)\{\
11 		newdel = p.newdefault(h,v,"vpdelay~", 10, 10, 0.5);\
12 		p.connect(source, 0, newdel, 0);\
13 		p.connect(sdel,0, newdel,1);\
14 		p.connect(sfeed,0, newdel,2);\
15 	\}\
16 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.6
\f0\b0  Benchmarking 
\i vpdelay~
\i0  with signal input for both feedback and delay time \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 idelay = (int) fdelay;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.10
\f0\b0  Replacing the function call 
\f1\fs20 trunc()\
\
\
\
FIX_DENORM_FLOAT(feedback_sample);\

\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.11
\f0\b0  Calling the Max/MSP macro to fix denormal numbers\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->sr = sys_getsr(); \
2 // code omitted\
3 x->delay_length = x->sr * x->maximum_delay_time + 1;\
4 x->delay_bytes = x->delay_length * sizeof(float);\
5 x->delay_line = (float *) sysmem_newptrclear(x->delay_bytes);\
6 // code omitted\
7 x->write_ptr = x->delay_line; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.13
\f0\b0  Dangerous initialization code\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 if(x->sr != sp[0]->s_sr)\{\
 2 	x->sr = sp[0]->s_sr; \
 3 	x->delay_length = x->sr * x->maximum_delay_time + 1;\
 4 	x->delay_bytes = x->delay_length * sizeof(float);\
 5 	x->delay_line = (float *) \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sysmem_resizeptrclear((void *)x->delay_line,\
\pard\pardeftab720\li1440\ri0\ql\qnatural
\cf0 x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  6 		if(x->delay_line == NULL)\{\
 7 			error("vpdelay~: cannot realloc %d bytes of memory", \
 8 				x->delay_bytes);\
 9 			return;\
10 		\}\
11 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.14
\f0\b0  A problem with pointers in the dsp method for 
\i vpdelay~\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page  1 void *vpdelay_new(t_symbol *s, short argc, t_atom *argv)\
 2 \{\
 3 	float delmax = 100.0, deltime = 100.0, feedback = 0.1;\
 4 	t_vpdelay *x = object_alloc(vpdelay_class);\
 5 	dsp_setup(&x->obj, 3);\
 6 	outlet_new((t_object *)x, "signal"); \
 7 	atom_arg_getfloat(&delmax, 0, argc, argv);\
 8 	atom_arg_getfloat(&deltime, 1, argc, argv);\
 9 	atom_arg_getfloat(&feedback, 2, argc, argv);\
10 	if(delmax <= 0)\{\
11 		delmax = 250.0;\
12 	\}\
13 	x->maximum_delay_time = delmax * 0.001; \
14 	x->delay_time = deltime; \
15 	if(x->delay_time > delmax || x->delay_time <= 0.0)\{\
16 		error("illegal delay time: %f, reset to 1 ms", \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 x->delay_time);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 		x->delay_time = 1.0;\
18 	\}\
19 	x->sr = 0.0; \
20 	x->feedback = feedback;\
21 	return x;\
22 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\i\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.15
\f0\b0  The revised new instance routine for 
\i vpdelay~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page  1 void vpdelay_dsp(t_vpdelay *x, t_signal **sp, short *count)\
 2 \{\
 3 	if(!sp[0]->s_sr)\{\
 4 		return;\
 5 	\}\
 6 	x->delaytime_connected = count[1];\
 7 	x->feedback_connected = count[2];\
 8 	if(x->sr != sp[0]->s_sr)\{\
 9 		x->sr = sp[0]->s_sr; \
10 		x->delay_length = x->sr * x->maximum_delay_time + 1;\
11 		x->delay_bytes = x->delay_length * sizeof(float);\
12 		if(x->delay_line == NULL)\{\
13 			x->delay_line = \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 (float *) sysmem_newptrclear(x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 14 		\}\
15 		else \{\
16 			x->delay_line = (float *) \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 sysmem_resizeptrclear((void *)x->delay_line,\
x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 17 		\}\
18 		if(x->delay_line == NULL)\{\
19 			error("vpdelay~: cannot realloc %d bytes of memory", \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 x->delay_bytes);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 20 			return;\
21 		\}\
22 		x->write_ptr = x->delay_line; \
23 	\}\
24 	dsp_add(vpdelay_perform, 6, x, sp[0]->s_vec, sp[1]->s_vec,\
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 25 \}
\f0\fs24  \
\

\f1\fs20 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 9.16
\f0\b0  Setting the write pointer and memory addresses in the dsp method\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 \page \pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 t_class *c = oscil_class = class_new("oscil_attributes~",   \
  (method)oscil_new,(method)oscil_free, sizeof(t_oscil), 0,A_GIMME,0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 \
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.1
\f0\b0  Using a temporary class variable for more compact code\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 CLASS_ATTR_FLOAT(c, "frequency", 0, t_oscil, a_frequency);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.2
\f0\b0  Creating a float attribute for frequency\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 x->a_frequency = 440.0;\
2 attr_args_process(x, argc, argv);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.3
\f0\b0  Processing the frequency attribute in the new instance routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 t_max_err a_frequency_set(t_oscil *x, void *attr, long ac, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *av) \
\pard\pardeftab720\ri0\ql\qnatural
\cf0 2 \{\
3 	if (ac&&av) \{\
4 		x->a_frequency = atom_getfloat(av);\
5 		x->si = x->a_frequency * x->si_factor;\
6 	\} \
7 	return MAX_ERR_NONE;\
8 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.5
\f0\b0  Overriding the 
\f1\fs20 a_frequency_set()
\f0  
\fs24 method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 CLASS_ATTR_ACCESSORS(c, "frequency", NULL, a_frequency_set);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.6
\f0\b0  Binding the frequency message in the initialization routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 long a_xfadetype; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.8
\f0\b0  The object structure component for a fadetype attribute\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f4\fs20 \cf0 \page \pard\pardeftab720\ri0\ql\qnatural

\f1 \cf0 1 CLASS_ATTR_LONG(c, "xfade", 0, t_oscil, a_xfadetype);\
2 CLASS_ATTR_LABEL(c, "xfade", 0, "Crossfade");\
3 CLASS_ATTR_ENUMINDEX(c, "xfade", 0, "\\"No Fade\\" \\"Linear Fade\\" \\"Equal Power Fade\\"");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.9
\f0\b0  Attribute macro calls to define the 
\f1\fs20 xfade
\f0\fs24  attribute and its behavior\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 long xfadetype = x->a_xfadetype;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.10
\f0\b0  Dereferencing the fadetype attribute in the perform routine\
\
\
\
\pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 t_symbol *a_waveform; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.11
\f0\b0  The waveform attribute component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 CLASS_ATTR_SYM(c, "waveform", 0, t_oscil, a_waveform);\
2 CLASS_ATTR_LABEL(c, "waveform", 0, "Oscillator Waveform");\
3 CLASS_ATTR_ENUM(c, "waveform", 0, "Sine Triangle Square Sawtooth Pulse Additive");\
4 CLASS_ATTR_ACCESSORS(c, "waveform", NULL, a_waveform_set);\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________\
\pard\pardeftab720\ri0\ql\qnatural

\f3\b\fs24 \cf0 Figure 10.12
\f0\b0  Defining the 
\f1\fs20 waveform
\f0\fs24  attribute\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 t_max_err a_waveform_set(t_oscil *x, void *attr, long ac, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *av) \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{	\
 3 	if (av) \{\
 4 		x->a_waveform = atom_getsym(av);\
 5 		if (x->a_waveform == gensym("Sine")) \{\
 6 			oscil_sine(x);\
 7 		\} else if (x->a_waveform == gensym("Triangle")) \{\
 8 			oscil_triangle(x);\
 9 		\} else if (x->a_waveform == gensym("Square")) \{\
10 			oscil_square(x);\
11 		\} else if (x->a_waveform == gensym("Sawtooth")) \{\
12 			oscil_sawtooth(x);\
13 		\} else if (x->a_waveform == gensym("Pulse")) \{\
14 			oscil_pulse(x);\
15 		\} else if(x->a_waveform == gensym("Additive"))\{\
16 			oscil_additive(x);\
17 		\}\
18 		else \{ \
19 			error("%s is not a legal waveform", \
\pard\pardeftab720\li2160\fi720\ri0\ql\qnatural
\cf0 x->waveform->s_name);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 20 			oscil_sine(x);\
21 		\}	\
22 	\}\
23 	return MAX_ERR_NONE;\
24 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.13
\f0\b0  The waveform setter method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 t_float a_amplitudes[8];\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.14
\f0\b0  Defining an attribute array with static memory\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 t_float *a_amplitudes;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.15
\f0\b0  The amplitude array component\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 CLASS_ATTR_FLOAT_ARRAY(c,"amplitudes",0,t_oscil,a_amplitudes, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 OSCIL_MAX_HARMS);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 2 CLASS_ATTR_ACCESSORS(c, "amplitudes", a_amplitudes_get, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 a_amplitudes_set);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 3 CLASS_ATTR_LABEL(c, "amplitudes", 0, "Harmonic Weightings");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.16
\f0\b0  Defining the amplitudes attribute in
\fs20  
\fs24 the initialization routine\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 t_max_err a_amplitudes_set(t_oscil *x, void *attr, long ac, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *av) \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	int i;\
 4 	t_atom *rv = NULL;\
 5 	if (ac&&av) \{\
 6 		for(i = 0; i < OSCIL_MAX_HARMS; i++)\{\
 7 			x->a_amplitudes[i] = atom_getfloatarg(i, ac, av);\
 8 		\}\
 9 	\} \
10 	object_method_sym((t_object *)x, gensym("waveform"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("Additive"), rv);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	return MAX_ERR_NONE;\
12 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.17
\f0\b0  Allocating memory for the amplitudes attribute\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 t_max_err a_amplitudes_set(t_oscil *x, void *attr, long ac, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom *av) \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	int i;\
 4 	t_atom *rv = NULL;\
 5 	if (ac&&av) \{\
 6 		for(i = 0; i < OSCIL_MAX_HARMS; i++)\{\
 7 			x->a_amplitudes[i] = atom_getfloatarg(i, ac, av);\
 8 		\}\
 9 	\} \
10 	object_method_sym((t_object *)x, gensym("waveform"), \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 gensym("Additive"), rv);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 11 	return MAX_ERR_NONE;\
12 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.18
\f0\b0  The 
\f1\fs20 amplitudes
\f0\fs24  setter method\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page  1 t_max_err a_amplitudes_get(t_oscil *x, void *attr, long *ac, \
\pard\pardeftab720\fi720\ri0\ql\qnatural
\cf0 t_atom **av) \
\pard\pardeftab720\ri0\ql\qnatural
\cf0  2 \{\
 3 	int i;\
 4 	\
 5 	if (!((*ac)&&(*av))) \{\
 6 		*ac = OSCIL_MAX_HARMS;\
 7 		if (!(*av = (t_atom *)sysmem_newptr(sizeof(t_atom) * \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (*ac)))) \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 \{\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  8 			*ac = 0;\
 9 			return MAX_ERR_OUT_OF_MEM;\
10 		\}\
11 	\}\
12 	for(i = 0; i < OSCIL_MAX_HARMS; i++)\{\
13 		atom_setfloat(*av + i,x->a_amplitudes[i]);\
14 	\}\
15 	return MAX_ERR_NONE;\
16 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.19
\f0\b0  The 
\f1\fs20 amplitudes
\f0\fs24  getter method\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 void oscil_additive(t_oscil *x)\
 2 \{\
 3 	int i;\
 4 	x->harmonic_count = 0;\
 5 	for(i = 0; i < OSCIL_MAX_HARMS; i++)\{\
 6 		x->amplitudes[i] = x->a_amplitudes[i];\
 7 		if(x->a_amplitudes[i])\{\
 8 			x->harmonic_count = i;\
 9 		\}\
10 	\} \
11 	oscil_build_waveform(x);\
12 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.20
\f0\b0  The 
\f1\fs20 oscil_additive()
\f0\fs24  routine\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 CLASS_ATTR_ORDER(c, "frequency", 0, "1");\
2 CLASS_ATTR_ORDER(c, "waveform", 0, "2");\
3 CLASS_ATTR_ORDER(c, "xfade", 0, "3");\
4 CLASS_ATTR_ORDER(c, "amplitudes", 0, "4");\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 10.21
\f0\b0  Defining the order of appearance for the attributes of 
\i oscil~
\i0 \
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 #include "stdio.h"\
2 main()\
3 \{\
4   float x, y;\
5   y = x * z;\
6 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.1
\f0\b0  A defective C program with an easy-to-find bug\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 #include "stdio.h"\
 2 #include "stdlib.h"\
 3 main()\
 4 \{\
 5   float *mem1;\
 6   float *mem2;\
 7   int i;\
 8   int len = 32768;\
 9 \
10   mem1 = (float *) malloc(len * sizeof(float));\
11   mem1 = (float *) malloc(len * sizeof(float));\
12   for(i = 0; i < len; i++)\{\
13     mem1[i] = i;\
14   \}\
15   for(i = 0; i < len; i++)\{\
16     mem2[i] = mem1[i] * i;\
17   \}\
18 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.3
\f0\b0  A buggy program\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  \
\page  1 #include "stdio.h"\
 2 #include "stdlib.h"\
 3 #include "math.h"\
 4 #define TWOPI 3.1415926535898\
 5 \
 6 main()\
 7 \{\
 8   float line[64];\
 9   float sine[64];\
10   buildsine(line,sine,64);\
11 \}\
12 \
13 buildsine(float *line, float *sine, int length)\{\
14   int i;\
15   for(i = 0; i < length; i++)\{\
16     line[1] = TWOPI / length;\
17   \}\
18   for(i= 0; i < length; i++)\{\
19     sine[i] = sin(line[i]);\
20   \}\
21 \} \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.4
\f0\b0  A failed attempt to build and store a digital sine wave\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 main()\
 2 \{\
 3   int i;\
 4   float line[64];\
 5   float sine[64];\
 6   buildsine(line,sine,16);\
 7   for(i= 0; i < 16; i++)\{\
 8     printf("%f\\n",sine[i]);\
 9   \}\
10 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.5
\f0\b0  Rewriting the 
\f1\fs20 main()
\f0\fs24  program to print the data generated by 
\f1\fs20 buildsine()
\f0\fs24  \
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 line[i] = TWOPI / length;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.7
\f0\b0  Fixing the typo on line 16\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 line[i] = TWOPI * i / length;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.9
\f0\b0  Incorporating the index variable into the calculation\
\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 #define TWOPI 3.1415926535898\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.11
\f0\b0  Incorrectly defined constant for 2\uc0\u960 \
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \page \pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0  1 #include "m_pd.h"
\fs20 \

\fs18  2 static t_class *ramp_class;
\fs20 \

\fs18  3 
\fs20 \

\fs18  4 typedef struct _ramp
\fs20 \

\fs18  5 \{
\fs20 \

\fs18  6 	t_object obj;
\fs20 \

\fs18  7 	float x_f;
\fs20 \

\fs18  8 	long counter;
\fs20 \

\fs18  9 	long maximum;
\fs20 \

\fs18 10 \} t_ramp;
\fs20 \

\fs18 11 
\fs20 \

\fs18 12 void *ramp_new(void);
\fs20 \

\fs18 13 t_int *ramp_perform(t_int *w);
\fs20 \

\fs18 14 void ramp_dsp(t_ramp *x, t_signal **sp, short *count);
\fs20 \

\fs18 15 
\fs20 \

\fs18 16 void ramp_tilde_setup (void)
\fs20 \

\fs18 17 \{
\fs20 \

\fs18 18 	ramp_class = class_new(gensym("ramp~"), (t_newmethod)ramp_new,0, 
\fs20 \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural

\fs18 \cf0 sizeof(t_ramp), 0,A_GIMME,0);
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 19 	t_class *c; 
\fs20 \

\fs18 20 	class_addmethod(c, (t_method)ramp_dsp, gensym("dsp"), A_CANT, 0);
\fs20 \

\fs18 21 	CLASS_MAINSIGNALIN(c, t_ramp, x_f);
\fs20 \

\fs18 22 	post("ramp~: from \\"Designing Audio Objects \\" by Eric Lyon");
\fs20 \

\fs18 23 \}	
\fs20 \

\fs18 24 
\fs20 \

\fs18 25 void *ramp_new(void)
\fs20 \

\fs18 26 \{
\fs20 \

\fs18 27 	t_ramp *x = (t_ramp *)pd_new(ramp_class);
\fs20 \

\fs18 28 	inlet_new(&x->obj, &x->obj.ob_pd, gensym("signal"), 
\fs20 \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural

\fs18 \cf0 gensym("signal"));
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs18 \cf0 29     outlet_new(&x->obj, gensym("signal"));
\fs20 \

\fs18 30     outlet_new(&x->obj, gensym("signal"));
\fs20 \

\fs18 31 	 x->maximum = 44100;
\fs20 \

\fs18 32 	 x->counter = 0;
\fs20 \

\fs18 33     return NULL;
\fs20 \

\fs18 34 \}
\fs20 \

\fs18 35 
\fs20 \

\fs18 36 t_int *ramp_perform(t_int *w)
\fs20 \

\fs18 37 \{
\fs20 \

\fs18 38 	t_ramp *x = (t_ramp *) (w[1]);
\fs20 \

\fs18 39 	float *trigger = (t_float *)(w[2]);
\fs20 \

\fs18 40 	float *maxcount = (t_float *)(w[3]);
\fs20 \

\fs18 41 	float *out = (t_float *)(w[4]);
\fs20 \

\fs18 42 	int n = w[5];
\fs20 \

\fs18 43 	long maximum = x->maximum;
\fs20 \

\fs18 44 	long counter = x->counter;
\fs20 \

\fs18 45 	float invmax; 
\fs20 \

\fs18 46 	for(i = 0; i < n; i++)\{
\fs20 \

\fs18 47 		if(trigger[i])\{
\fs20 \

\fs18 48 			counter = 0;
\fs20 \

\fs18 49 			maximum = maxcount[i];
\fs20 \

\fs18 50 		\}
\fs20 \

\fs18 51 		out[i] = counter * invmax;
\fs20 \

\fs18 52 		if(counter < maximum)\{
\fs20 \

\fs18 53 			counter++;
\fs20 \

\fs18 54 		\}
\fs20 \

\fs18 55 	\}
\fs20 \

\fs18 56 	return w + 7;
\fs20 \

\fs18 57 \}
\fs20 \

\fs18 58 
\fs20 \

\fs18 59 void ramp_dsp(t_ramp *x, t_signal **sp, short *count)
\fs20 \

\fs18 60 \{
\fs20 \

\fs18 61 	dsp_add(ramp_perform, 7, x, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
\fs20 \

\fs18 62 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.13
\f0\b0  The defective code for 
\i ramp~
\i0 \
\page   
\f1\fs20 1 int main(void)\
 2 \{\
 3 	ramp_class = class_new("ramp~", (method)ramp_new, \
\pard\pardeftab720\li1440\fi720\ri0\ql\qnatural
\cf0 (method)dsp_free, sizeof(t_ramp), 0,0);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  4 	t_class *c;\
 5 	class_addmethod(c, (method)ramp_dsp, "dsp", A_CANT, 0);\
 6 	class_addmethod(c, (method)ramp_assist, "assist", A_CANT, 0);\
 7 	class_dspinit(c);\
 8 	class_register(CLASS_BOX, c);\
 9 	post("ramp~ from 
\f4 \\
\f1 \'94Designing Audio Objects
\f4 \\
\f1 \'94 by Eric Lyon\'94);\
10 	return 0;\
11 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.19
\f0\b0  The defective 
\f1\fs20 main()
\f0\fs24  function for 
\i ramp~
\i0  in Max/MSP\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 1 int count; // risky\
2 int count = 0; // safe\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.20
\f0\b0   Watch out for uninitialized variables\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0  1 int trouble[32];\
 2 int i;\
 3 \
 4 /* in this loop we go one address too far, ending with\
 5    an illegal write to the array trouble[]. */\
 6 \
 7 for(i = 0; i <= 32; i++)\{\
 8 	trouble[i] = i;\
 9 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 11.21
\f0\b0  Bad behavior at the extremes\
\pard\tx560\pardeftab720\ri0\ql\qnatural
\cf0 \page \pard\tx560\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct \{\
    OPDS    h;\
    MYFLT   *out, *in, *fco, *res, *max, *iskip;\
    double  xnm1, y1nm1, y2nm1, y3nm1, y1n, y2n, y3n, y4n;\
    MYFLT   maxint;\
    int16   fcocod, rezcod;\
\pard\pardeftab720\ri0\ql\qnatural

\f4 \cf0 \}
\f1  MOOGVCF;\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.2
\f0\b0  The unit generator structure for 
\i moogvcf\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 \page \pard\pardeftab720\ri0\ql\qnatural

\fs17 \cf0  1 static int moogvcf(CSOUND *csound, MOOGVCF *p)
\fs20 \

\fs17  2 \{
\fs20 \

\fs17  3     int n, nsmps = csound->ksmps;
\fs20 \

\fs17  4     MYFLT *out, *in;
\fs20 \

\fs17  5     double xn;
\fs20 \

\fs17  6     MYFLT *fcoptr, *resptr;
\fs20 \

\fs17  7     /* Fake initialisations to stop compiler warnings!! */
\fs20 \

\fs17  8     double fco, res, kp=0.0, pp1d2=0.0, scale=0.0, k=0.0;
\fs20 \

\fs17  9     double max = (double)p->maxint;
\fs20 \

\fs17 10     double dmax = 1.0/max;
\fs20 \

\fs17 11     double xnm1 = p->xnm1, y1nm1 = p->y1nm1,y2nm1 = p->y2nm1, 
\fs20 \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural

\fs17 \cf0 y3nm1 = p->y3nm1;
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs17 \cf0 12     double y1n  = p->y1n, y2n = p->y2n, y3n = p->y3n, y4n = p->y4n;
\fs20 \

\fs17 13     in      = p->in;
\fs20 \

\fs17 14     out     = p->out;
\fs20 \

\fs17 15     fcoptr  = p->fco;
\fs20 \

\fs17 16     resptr  = p->res;
\fs20 \

\fs17 17     fco     = (double)*fcoptr;
\fs20 \

\fs17 18     res     = (double)*resptr;
\fs20 \

\fs17 19   /* Only need to calculate once */
\fs20 \

\fs17 20     if (UNLIKELY((p->rezcod==0) && (p->fcocod==0))) \{
\fs20 \

\fs17 21       double fcon;
\fs20 \

\fs17 22       fcon  = 2.0*fco*(double)csound->onedsr; /* normalised frq. 0 to Nyq */
\fs20 \

\fs17 23       kp    = 3.6*fcon-1.6*fcon*fcon-1.0;     /* Empirical tuning   */
\fs20 \

\fs17 24       pp1d2 = (kp+1.0)*0.5;                   /* Timesaver          */
\fs20 \

\fs17 25       scale = exp((1.0-pp1d2)*1.386249);      /* Scaling factor     */
\fs20 \

\fs17 26       k     = res*scale;
\fs20 \

\fs17 27     \}
\fs20 \

\fs17 28     for (n=0; n<nsmps; n++) \{
\fs20 \

\fs17 29       /* Handle a-rate modulation of fco & res. */
\fs20 \

\fs17 30       if (p->fcocod) \{
\fs20 \

\fs17 31         fco = (double)fcoptr[n];
\fs20 \

\fs17 32       \}
\fs20 \

\fs17 33       if (p->rezcod) \{
\fs20 \

\fs17 34         res = (double)resptr[n];
\fs20 \

\fs17 35       \}
\fs20 \

\fs17 36       if ((p->rezcod!=0) || (p->fcocod!=0)) \{
\fs20 \

\fs17 37         double fcon;
\fs20 \

\fs17 38         fcon  = 2.0*fco*(double)csound->onedsr; /* normalised frq. 0 to Nyquist */
\fs20 \

\fs17 39         kp    = 3.6*fcon-1.6*fcon*fcon-1.0;     /* Empirical tuning */
\fs20 \

\fs17 40         pp1d2 = (kp+1.0)*0.5;                   /* Timesaver */
\fs20 \

\fs17 41         scale = exp((1.0-pp1d2)*1.386249);      /* Scaling factor */
\fs20 \

\fs17 42         k     = res*scale;
\fs20 \

\fs17 43       \}
\fs20 \

\fs17 44       xn = (double)in[n] * dmax;
\fs20 \

\fs17 45       xn = xn - k * y4n; /* Inverted feed back for corner peaking */
\fs20 \

\fs17 46       /* Four cascaded onepole filters (bilinear transform) */
\fs20 \

\fs17 47       y1n   = (xn  + xnm1 ) * pp1d2 - kp * y1n;
\fs20 \

\fs17 48       y2n   = (y1n + y1nm1) * pp1d2 - kp * y2n;
\fs20 \

\fs17 49       y3n   = (y2n + y2nm1) * pp1d2 - kp * y3n;
\fs20 \

\fs17 50       y4n   = (y3n + y3nm1) * pp1d2 - kp * y4n;
\fs20 \

\fs17 51                                 /* Clipper band limited sigmoid */
\fs20 \

\fs17 52       y4n   = y4n - y4n * y4n * y4n / 6.0;
\fs20 \

\fs17 53       xnm1  = xn;       /* Update Xn-1  */
\fs20 \

\fs17 54       y1nm1 = y1n;      /* Update Y1n-1 */
\fs20 \

\fs17 55       y2nm1 = y2n;      /* Update Y2n-1 */
\fs20 \

\fs17 56       y3nm1 = y3n;      /* Update Y3n-1 */
\fs20 \

\fs17 57       out[n]   = (MYFLT)(y4n * max);
\fs20 \

\fs17 58     \}
\fs20 \

\fs17 59     p->xnm1 = xnm1; p->y1nm1 = y1nm1; p->y2nm1 = y2nm1; 
\fs20 \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural

\fs17 \cf0 p->y3nm1 = y3nm1;
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\fs17 \cf0 60     p->y1n  = y1n;  p->y2n  = y2n; p->y3n = y3n; p->y4n = y4n;
\fs20 \

\fs17 61     return OK;
\fs20 \

\fs17 62 \}
\fs20 \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.3
\f0\b0  C code for the Csound 
\i moogvcf
\i0  unit generator\page \pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 if ((p->rezcod==0) && (p->fcocod==0))\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.4
\f0\b0  The condition for computing new coefficients at the control rate\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 typedef struct _moogvcf\
\pard\pardeftab720\ri0\ql\qnatural

\f4 \cf0 \{
\f1 \

\f4 	
\f1 t_pxobject obj;\

\f4 	
\f1 double  xnm1, y1nm1, y2nm1, y3nm1, y1n, y2n, y3n, y4n;\

\f4 	
\f1 double onedsr; // one divided by the sample rate\

\f4 \}
\f1  t_moogvcf;\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.5
\f0\b0  The object structure for a Max/MSP implementation of 
\i moogvcf~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 1 void moogvcf_dsp(t_moogvcf *x, t_signal **sp, short *count)\
2 \{\
3 	if(sp[0]->s_sr)\{\
4 		x->onedsr = 1.0 / sp[0]->s_sr;\
5 		dsp_add(moogvcf_perform, 6, x, sp[0]->s_vec, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0   sp[1]->s_vec,sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);\
\pard\pardeftab720\ri0\ql\qnatural
\cf0 6 	\}\
7 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.6
\f0\b0  Setting the value of 
\f1\fs20 onedsr\
\
\
\
\page  1 t_int *moogvcf_perform(t_int *w)\
 2 \{\
 3 	t_moogvcf *x = (t_moogvcf *) (w[1]);\
 4 	float *input = (t_float *)(w[2]);\
 5 	float *frequency = (t_float *)(w[3]);\
 6 	float *resonance = (t_float *)(w[4]);\
 7 	float *output = (t_float *)(w[5]);\
 8 	int n = w[6];\
 9 	double fcon;\
10 	double onedsr = x->onedsr;\
11    double kp=0.0, pp1d2=0.0, scale=0.0, k=0.0;\
12 	double xn;\
13    double xnm1 = x->xnm1, y1nm1 = x->y1nm1, \
\pard\pardeftab720\ri0\ql\qnatural

\f4 \cf0 		
\f1 y2nm1 = x->y2nm1, y3nm1 = x->y3nm1;\
14    double y1n  = x->y1n, y2n = x->y2n, y3n = x->y3n, y4n = x->y4n;	\
15 	while(n--)\{\
16 		fcon  = 2.0 * *frequency++ * onedsr; \

\f4 			
\f1 /* normalised frq. 0 to Nyquist */\
17          kp    = 3.6*fcon-1.6*fcon*fcon-1.0;     \

\f4 			
\f1 /* Empirical tuning */\
18          pp1d2 = (kp+1.0)*0.5;                   \

\f4 			
\f1 /* Timesaver */\
19 		scale = exp((1.0-pp1d2)*1.386249);      \

\f4 			
\f1 /* Scaling factor */\
20          k     = *resonance++ * scale;\
21 		xn = *input++;\
22 		xn = xn - k * y4n; \

\f4 			
\f1 /* Inverted feed back for corner peaking */\
23 		y1n   = (xn  + xnm1 ) * pp1d2 - kp * y1n;\
24 		y2n   = (y1n + y1nm1) * pp1d2 - kp * y2n;\
25 		y3n   = (y2n + y2nm1) * pp1d2 - kp * y3n;\
26 		y4n   = (y3n + y3nm1) * pp1d2 - kp * y4n;\
27 		y4n   = y4n - y4n * y4n * y4n / 6.0;\
28 		xnm1  = xn;       /* Update Xn-1  */\
29 		y1nm1 = y1n;      /* Update Y1n-1 */\
30 		y2nm1 = y2n;      /* Update Y2n-1 */\
31 		y3nm1 = y3n;      /* Update Y3n-1 */\
32 		*output++   =  y4n;\
33 	\}\
34     x->xnm1 = xnm1; x->y1nm1 = y1nm1; \

\f4 		
\f1 x->y2nm1 = y2nm1; x->y3nm1 = y3nm1;\
35     x->y1n  = y1n;  x->y2n  = y2n; x->y3n = y3n; x->y4n = y4n;\
36 	return w + 7;\
37 \}\
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.7
\f0\b0  The perform routine for 
\i moogvcf~\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f1\i0\fs20 \cf0 fcon  = 1.78179 * *frequency++ * onedsr; \
\pard\pardeftab720\ri0\ql\qnatural

\f0\fs24 \cf0 \
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 _____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 12.9
\f0\b0  Adjusting the tuning of 
\i moogvcf~
\i0 \
\page   
\f1\fs20 1 var points = 8192;\
 2 outlets = 2;\
 3 function linefunc1(segs)\{\
 4     var seglen = points / segs;\
 5     var firstpoint = x1 = (Math.random() * 2) - 1;\
 6     var x2 = (Math.random() * 2) - 1;\
 7     var i,j;\
 8     var sample, frac;\
 9     for(i = 0; i < segs; i++)\{\
10         for(j = 0; j < seglen; j++)\{\
11             sample = x1 + ((j/seglen) * (x2 - x1));\
12             outlet(1, (i*seglen)+j);\
13             outlet(0, sample);\
14         \}\
15         x1 = x2;\
16         if(i == segs - 2)\{\
17             x2 = firstpoint;\
18         \} else \{\
19             x2 = (Math.random() * 2) - 1;\
20         \}\
21     \}        \
22 \}\
 _____________________________________________________________________
\f0\fs24 \

\f3\b Figure 13.1
\f0\b0  JavaScript code to initialize a stochastic waveform\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\
\
\
 \
\page  1 var length = 16;\
 2 var sequence = new Array(length);\
 3 \
 4 randomize(length);\
 5 \
 6 function getfreq(index)\
 7 \{\
 8    outlet(0, sequence[index]);\
 9 \}\
10 \
11 function randomize(length)\
12 \{\
13 	var i;\
14 	for(i = 0; i < length; i++)\{\
15 	
\f4 	
\f1 sequence[i] = 60 + (Math.random() * 400);\
16 	
\f4 \}
\f1 \
17 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 14.5
\f0\b0  The live-sequencer JavaScript code\
\pard\pardeftab720\ri0\ql\qnatural

\f1\fs20 \cf0 \
\page  1 void dsp_add(t_perfroutine f, int n, ...)\
 2 \{\
 3     int newsize = dsp_chainsize + n+1, i;\
 4     va_list ap;\
 5 \
 6     dsp_chain = t_resizebytes(dsp_chain, \
\pard\pardeftab720\li720\fi720\ri0\ql\qnatural
\cf0 dsp_chainsize * sizeof (t_int), newsize * sizeof (t_int));\
\pard\pardeftab720\ri0\ql\qnatural
\cf0  7     dsp_chain[dsp_chainsize-1] = (t_int)f;\
 8     va_start(ap, n);\
 9     for (i = 0; i < n; i++)\
10         dsp_chain[dsp_chainsize + i] = va_arg(ap, t_int);\
11     va_end(ap);\
12     dsp_chain[newsize-1] = (t_int)dsp_done;\
13     dsp_chainsize = newsize;\
14 \}\
\
_____________________________________________________________________
\f0\fs24 \
\pard\pardeftab720\ri0\ql\qnatural

\f3\b \cf0 Figure 15.2
\f0\b0  The function 
\f1\fs20 dsp_add()
\f0\fs24  from the Pd source code\
\
\
\
\
\
\pard\pardeftab720\ri0\ql\qnatural

\f2\b\fs26 \cf0 \
}